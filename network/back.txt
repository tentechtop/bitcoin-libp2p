package network

import (
	"bitcoin/blockchain"
	"bitcoin/db"
	"bitcoin/event"
	"bufio"
	"context"
	"crypto/rand"
	"encoding/binary"
	"errors"
	"fmt"
	"google.golang.org/protobuf/proto"

	"bitcoin/wire"

	"github.com/libp2p/go-libp2p"
	dht "github.com/libp2p/go-libp2p-kad-dht"
	"github.com/libp2p/go-libp2p/core/crypto"
	"github.com/libp2p/go-libp2p/core/discovery"
	"github.com/libp2p/go-libp2p/core/host"
	"github.com/libp2p/go-libp2p/core/network"
	"github.com/libp2p/go-libp2p/core/peer"
	"github.com/libp2p/go-libp2p/core/protocol"
	"github.com/libp2p/go-libp2p/p2p/discovery/mdns"
	"github.com/libp2p/go-libp2p/p2p/discovery/routing"
	"github.com/libp2p/go-libp2p/p2p/host/autonat"
	noise "github.com/libp2p/go-libp2p/p2p/security/noise"
	quic "github.com/libp2p/go-libp2p/p2p/transport/quic"
	"github.com/libp2p/go-libp2p/p2p/transport/tcp"
	"github.com/multiformats/go-multiaddr"
	manet "github.com/multiformats/go-multiaddr/net"
	"golang.org/x/net/proxy"
	"golang.org/x/sync/errgroup"
	"golang.org/x/time/rate"
	"io"
	"net"
	"os"
	"strings"
	"sync"
	"time"
)

// 网络层已经节点 都是在线节点
// 节点连接就保存或者更新完整节点信息    已经连接
// 节点断开连接就保存或者更新完整节点信息 已经断开

// ProtocolHandler 定义协议处理函数类型
type ProtocolHandler func(peerID string, data []byte) ([]byte, error)

// NetworkLayer 网络层接口
type NetworkLayer interface {
	SavePeers() error
	Start() error
	Stop() error
	SelfID() string
	SelfAddrs() []multiaddr.Multiaddr
	Connect(peerInfo PeerInfo) error
	Disconnect(peerID string) error
	ConnectedPeers() []PeerInfo
	Send(peerID string, proto protocol.ID, data []byte) ([]byte, error)
	Broadcast(proto protocol.ID, data []byte) map[string]error
	RegisterProtocol(proto protocol.ID, handler ProtocolHandler)
	DiscoverPeers() (<-chan PeerInfo, error)
}

// 连接方向（与Protobuf的ConnectionDirection对应）
type ConnectionDirection int

const (
	DirUnknown  ConnectionDirection = iota // 未知方向
	DirInbound                             // 入站连接（其他节点主动连接本地）
	DirOutbound                            // 出站连接（本地主动连接其他节点）
)

// 握手状态（与Protobuf的HandshakeStatus对应）
type HandshakeStatus int

const (
	ServiceNone     ServiceFlag = 0 // 无特殊服务
	ServiceFullNode ServiceFlag = 1 // 全节点（存储完整区块链）
	ServiceSPV      ServiceFlag = 2 // SPV节点（简化支付验证）
	ServiceMiner    ServiceFlag = 4 // 挖矿节点（支持挖矿相关消息）
	ServiceRelay    ServiceFlag = 8 // 中继节点（转发交易和区块）
)

// PersistentPeer 节点持久化信息结构体
// 与ProtoPersistentPeer完全对齐，增加了转换方法
type PersistentPeer struct {
	ID       string   `json:"id"`        // peer.ID 的字符串形式
	Addrs    []string `json:"addrs"`     // multiaddr 字符串形式
	LastSeen int64    `json:"last_seen"` // 最后活跃时间（时间戳）

	// 1. 连接元数据
	Direction   ConnectionDirection `json:"direction"`    // 连接方向
	ConnTime    int64               `json:"conn_time"`    // 连接建立时间戳
	DisconnTime int64               `json:"disconn_time"` // 最后断开时间戳（-1 表示当前连接）
	UserAgent   string              `json:"user_agent"`   // 用户代理

	// 2. 协议与能力
	ProtocolVersion uint32        `json:"protocol_version"` // 协商后的 P2P 协议版本
	Services        []ServiceFlag `json:"services"`         // 支持的服务能力
	SupportedMsgs   []string      `json:"supported_msgs"`   // 支持的消息类型列表

	// 3. 连接质量
	RTT         uint32            `json:"rtt"`          // 往返延迟（毫秒）
	MsgCount    map[string]uint64 `json:"msg_count"`    // 消息类型统计
	BytesSent   uint64            `json:"bytes_sent"`   // 累计发送字节数
	BytesRecv   uint64            `json:"bytes_recv"`   // 累计接收字节数
	UptimeRatio float32           `json:"uptime_ratio"` // 历史 uptime 占比（0.0~1.0）

	// 4. 安全与行为
	BanScore        uint32          `json:"ban_score"`        // 违规积分
	BanUntil        int64           `json:"ban_until"`        // 封禁截止时间戳（-1 表示未封禁）
	LastErr         string          `json:"last_err"`         // 最后一次错误信息
	HandshakeStatus HandshakeStatus `json:"handshake_status"` // 握手状态

	// 5. 重连策略
	RetryCount    uint32 `json:"retry_count"`    // 历史重连次数
	RetryInterval uint32 `json:"retry_interval"` // 下次重连间隔（秒）
	IsTrusted     bool   `json:"is_trusted"`     // 是否为可信节点
}

// PeerInfo 节点信息
type PeerInfo struct {
	ID      string
	Addrs   []multiaddr.Multiaddr
	Latency int64 // 延迟（毫秒），可选
}

// Config 网络层配置
type Config struct {
	Chain          *blockchain.BlockChain
	DB             db.KeyValueStore
	Bus            *event.Bus
	ListenPort     int
	DataDir        string
	BootstrapPeers []string
	ProtocolPrefix string // 必须以 / 开头，如 "/myblockchain"
	EnableQUIC     bool
	EnableMDNS     bool
	Logger         Logger
	ProxyType      string // 代理类型，如 "socks5"（目前主流支持）
	ProxyAddr      string // 代理地址，如 "127.0.0.1:1080"
	ProxyUser      string // 代理用户名（可选）
	ProxyPasswd    string // 代理密码（可选）
}

const (
	discoveryLimit   = 32 // 每轮发现最多拿 32 个节点
	discoveryTimeout = 10 * time.Second
	chanBufSize      = 128 // peerCh 缓冲，防止阻塞
	workerNum        = 4   // 并发 worker 数
)

const (
	maxMsgSize    = 1 << 20          // 1 MiB
	perPeerRate   = 10 * 1024 * 1024 // 10 MiB/s
	perPeerBurst  = 2 * 1024 * 1024  // 2 MiB burst
	readDeadline  = 10 * time.Second
	writeDeadline = 10 * time.Second
)

// peerLimiter 每个 peer 一个限速器
var peerLimiter sync.Map // map[string]*rate.Limiter
func getLimiter(pid peer.ID) *rate.Limiter {
	l, _ := peerLimiter.LoadOrStore(string(pid), rate.NewLimiter(rate.Limit(perPeerRate), perPeerBurst))
	return l.(*rate.Limiter)
}

var probeCache sync.Map

// Logger 日志接口
type Logger interface {
	Printf(format string, v ...interface{})
	Println(v ...interface{})
	Fatalf(format string, v ...interface{})
}

// defaultLogger 默认日志实现
type defaultLogger struct{}

func (d *defaultLogger) Printf(format string, v ...interface{}) {
	fmt.Printf(format, v...)
}
func (d *defaultLogger) Println(v ...interface{}) {
	fmt.Println(v...)
}
func (d *defaultLogger) Fatalf(format string, v ...interface{}) {
	fmt.Printf(format, v...)
	os.Exit(1)
}

// networkLayer 网络层实现
type networkLayer struct {
	db          db.KeyValueStore
	chain       *blockchain.BlockChain
	bus         *event.Bus
	ctx         context.Context // 主上下文
	cancel      context.CancelFunc
	wg          sync.WaitGroup // 用于等待 goroutine 退出
	config      Config
	host        host.Host
	dht         *dht.IpfsDHT
	routingDisc *routing.RoutingDiscovery
	handlers    map[protocol.ID]ProtocolHandler

	running           bool
	saveDebounceTimer *time.Timer   // 防抖定时器
	saveDebounceDelay time.Duration // 防抖延迟时间，例如5秒
	saveMutex         sync.Mutex    // 保护定时器的互斥锁
	handlerMu         sync.RWMutex
	retryMutex        sync.Mutex
	retryInterval     time.Duration // 初始退避时间
	maxRetries        int           // 最大重试次数
	nat               autonat.AutoNAT
	mdnsService       mdns.Service // 新增：保存 mDNS 实例
}

// NewNetworkLayer 创建新的网络层实例
func NewNetworkLayer(ctx context.Context, config Config) (NetworkLayer, error) {
	// 校验协议前缀格式
	if len(config.ProtocolPrefix) == 0 || config.ProtocolPrefix[0] != '/' {
		return nil, fmt.Errorf("ProtocolPrefix 必须以 / 开头（如 \"/myblockchain\"）")
	}

	// 设置默认日志
	if config.Logger == nil {
		config.Logger = &defaultLogger{}
	}

	// 创建带取消功能的上下文
	ctx, cancel := context.WithCancel(ctx)

	// 创建代理拨号器
	/*	proxyDialer, err := newProxyDialer(chaincfg)
		if err != nil {
			cancel()
			return nil, fmt.Errorf("初始化代理失败：%w", err)
		}*/
	//TODO 传入密钥和节点列表

	// 生成或加载节点密钥
	privKey, err := LoadOrGenerateKey(config.DB)
	if err != nil {
		cancel()
		return nil, fmt.Errorf("加载密钥失败: %w", err)
	}

	// 配置监听地址
	listenAddrs := make([]multiaddr.Multiaddr, 0)
	tcpAddr, err := multiaddr.NewMultiaddr(fmt.Sprintf("/ip4/0.0.0.0/tcp/%d", config.ListenPort))
	if err != nil {
		cancel()
		return nil, fmt.Errorf("创建TCP地址失败: %w", err)
	}
	listenAddrs = append(listenAddrs, tcpAddr)

	// 如果启用QUIC，添加QUIC监听地址
	if config.EnableQUIC {
		quicAddr, err := multiaddr.NewMultiaddr(fmt.Sprintf("/ip4/0.0.0.0/udp/%d/quic-v1", config.ListenPort))
		if err != nil {
			config.Logger.Printf("创建QUIC地址失败，将仅使用TCP: %v", err)
		} else {
			listenAddrs = append(listenAddrs, quicAddr)
		}
	}

	// 配置LibP2P选项
	opts := []libp2p.Option{
		libp2p.Identity(privKey),
		libp2p.ListenAddrs(listenAddrs...),
		libp2p.Transport(tcp.NewTCPTransport),
		libp2p.EnableNATService(),
		libp2p.EnableHolePunching(),
		libp2p.NATPortMap(),
		libp2p.DefaultMuxers,                 //默认启用了 Yamux 和 Mplex 两个流复用器。 Yamux 性能更好，Mplex 已逐步弃用
		libp2p.Security(noise.ID, noise.New), //默认会尝试使用 Noise 和 TLS 两个加密协议。 明确指定 Noise，更安全、更轻量、更可控。 libp2p.Security(tls.ID, tls.New),
	}

	// 如果启用QUIC，添加QUIC传输
	if config.EnableQUIC {
		opts = append(opts, libp2p.Transport(quic.NewTransport))
	}

	// 创建主机
	h, err := libp2p.New(opts...)
	if err != nil {
		cancel()
		return nil, fmt.Errorf("创建LibP2P主机失败: %w", err)
	}

	// 创建DHT
	kad, err := dht.New(ctx, h,
		dht.Mode(dht.ModeServer),
		dht.ProtocolPrefix(protocol.ID(config.ProtocolPrefix+"/dht")),
	)
	if err != nil {
		h.Close()
		cancel()
		return nil, fmt.Errorf("创建DHT失败: %w", err)
	}

	// 初始化网络层实例
	nl := &networkLayer{
		db:                config.DB,
		chain:             config.Chain,
		bus:               config.Bus,
		ctx:               ctx,
		cancel:            cancel,
		config:            config,
		host:              h,
		dht:               kad,
		handlers:          make(map[protocol.ID]ProtocolHandler),
		running:           false,
		saveDebounceDelay: 3 * time.Second, // 设置1秒防抖延迟
		saveDebounceTimer: nil,
	}

	// 初始化 AutoNAT
	nat, err := autonat.New(h)
	if err != nil {
		config.Logger.Printf("AutoNAT 初始化失败: %v", err)
	} else {
		nl.nat = nat
	}

	nl.host.SetStreamHandler(protocol.ID(config.ProtocolPrefix), nl.handleStream)

	return nl, nil
}

// newProxyDialer 根据配置创建代理拨号器
func newProxyDialer(cfg Config) (proxy.ContextDialer, error) {
	if cfg.ProxyType == "" || cfg.ProxyAddr == "" {
		return nil, nil // 无代理配置，返回nil（使用默认拨号）
	}
	// 仅支持 SOCKS5（libP2P 对 SOCKS5 支持最成熟）
	if cfg.ProxyType != "socks5" {
		return nil, fmt.Errorf("仅支持 socks5 代理，当前类型：%s", cfg.ProxyType)
	}
	// 配置 SOCKS5 认证（若有）
	var auth *proxy.Auth
	if cfg.ProxyUser != "" && cfg.ProxyPasswd != "" {
		auth = &proxy.Auth{
			User:     cfg.ProxyUser,
			Password: cfg.ProxyPasswd,
		}
	}
	// 创建 SOCKS5 代理拨号器（使用 golang.org/x/net/proxy）
	dialer, err := proxy.SOCKS5("tcp", cfg.ProxyAddr, auth, proxy.Direct)
	if err != nil {
		return nil, fmt.Errorf("创建 SOCKS5 代理失败：%w", err)
	}
	// 断言为 ContextDialer（确保支持上下文）
	ctxDialer, ok := dialer.(proxy.ContextDialer)
	if !ok {
		return nil, errors.New("代理拨号器不支持 ContextDialer 接口")
	}
	return ctxDialer, nil
}

// Start 启动网络层
func (n *networkLayer) Start() error {

	if n.running {
		return nil
	}

	// 启动DHT
	if err := n.dht.Bootstrap(n.ctx); err != nil {
		return fmt.Errorf("DHT启动失败: %w", err)
	}

	// 初始化路由发现
	n.routingDisc = routing.NewRoutingDiscovery(n.dht)

	// 如果启用mDNS，启动mDNS服务（修复：确保nl引用正确）
	if n.config.EnableMDNS {
		//serviceName := "/myblockchain/mdns" // 两个节点必须使用相同的名称
		go func() {
			// 创建mDNS服务
			mdnsService := mdns.NewMdnsService(n.host, n.config.ProtocolPrefix, &mdnsNotifee{nl: n})
			// 保存服务实例
			mdnsService.Start()
			n.mdnsService = mdnsService
			n.config.Logger.Println("mDNS服务启动成功")
			// 等待退出信号
			<-n.ctx.Done()
			// 收到退出信号，关闭mDNS服务
			if err := mdnsService.Close(); err != nil {
				n.config.Logger.Printf("mDNS服务关闭错误: %v", err)
			} else {
				n.config.Logger.Println("mDNS服务已关闭")
			}
			n.mdnsService = nil
		}()
	}

	// 连接到启动节点
	if err := n.connectBootstrapPeers(); err != nil {
		n.config.Logger.Printf("连接启动节点时出错: %v", err)
	}

	// 注册网络事件监听器（监听连接建立/断开）
	n.host.Network().Notify(&network.NotifyBundle{
		ConnectedF:    n.onPeerConnected,    // 新节点连接时
		DisconnectedF: n.onPeerDisconnected, // 节点断开时
	})

	n.config.Logger.Printf("DHT启动成功，初始路由表大小: %d", n.dht.RoutingTable().Size())

	n.running = true

	// 打印对外地址
	n.config.Logger.Printf("[NAT] 对外地址: %v", n.host.Addrs())

	n.config.Logger.Printf("当前节点ID: %s\n", n.SelfID())

	//启动节点发现
	_, err := n.DiscoverPeers()
	if err != nil {
		log.Infof("启动节点发现失败: %v", err)
	}

	// 1. 定期持久化节点列表
	go n.periodicSavePeers()

	// 2. 路由表变化日志
	go n.logRoutingTableDelta()

	// 3. 加载并连接持久化节点
	go n.connectPersistentPeers()

	return nil
}

// 1. 每 1h 保存一次节点列表
func (n *networkLayer) periodicSavePeers() {
	go func() {
		ticker := time.NewTicker(1 * time.Hour)
		defer ticker.Stop()
		for {
			select {
			case <-ticker.C:
				n.config.Logger.Println("定期保存节点列表")
				if err := n.SavePeers(); err != nil {
					n.config.Logger.Printf("定期保存节点失败: %v", err)
				}
			case <-n.ctx.Done():
				return
			}
		}
	}()
}

// 2. 仅当路由表长度变化时打印日志
func (n *networkLayer) logRoutingTableDelta() {
	go func() {
		lastSize := 0
		ticker := time.NewTicker(1 * time.Second)
		defer ticker.Stop()

		for {
			select {
			case <-n.ctx.Done():
				return
			case <-ticker.C:
				current := n.dht.RoutingTable().Size()
				if current != lastSize {
					n.config.Logger.Printf("路由表变化: %d -> %d", lastSize, current)
					lastSize = current
				}
			}
		}
	}()
}

// 3. 加载并连接持久化节点
func (n *networkLayer) connectPersistentPeers() {
	go func() {
		peers, err := n.loadPersistentPeers()
		if err != nil {
			n.config.Logger.Printf("加载持久化节点失败: %v", err)
			return
		}

		// 过滤引导节点
		bootstrapSet := make(map[string]struct{})
		for _, addr := range n.config.BootstrapPeers {
			if info, err := peer.AddrInfoFromP2pAddr(multiaddr.StringCast(addr)); err == nil {
				bootstrapSet[info.ID.String()] = struct{}{}
			}
		}
		var filtered []PersistentPeer
		for _, p := range peers {
			if _, ok := bootstrapSet[p.ID]; !ok {
				filtered = append(filtered, p)
			}
		}

		// 过滤过期 + 探活
		validPeers := n.filterExpiredPeersAsync(context.Background(), filtered, 24*time.Hour)
		n.config.Logger.Printf("加载到 %d 个持久化节点，过滤引导节点后 %d 个，过滤过期后有效节点 %d 个",
			len(peers), len(filtered), len(validPeers))

		for _, p := range validPeers {
			peerInfo, err := n.toPeerInfo(p)
			if err != nil {
				continue
			}
			if n.host.Network().Connectedness(peer.ID(peerInfo.ID)) == network.Connected {
				continue
			}
			if err := n.Connect(peerInfo); err != nil {
				n.config.Logger.Printf("连接持久化节点 %s 失败: %v", peerInfo.ID, err)
			} else {
				n.config.Logger.Printf("成功连接持久化节点: %s", peerInfo.ID)
			}
		}
	}()
}

// Stop 停止网络层
func (n *networkLayer) Stop() error {
	if !n.running {
		return nil
	}
	n.running = false

	// 2. 关闭所有连接
	for _, pid := range n.host.Network().Peers() {
		n.host.Network().ClosePeer(pid)
	}

	// 3. 取消上下文，通知所有 goroutine 退出
	n.cancel()

	// 4. 等待所有 goroutine 退出
	n.wg.Wait()

	// 5. 停止防抖定时器
	n.saveMutex.Lock()
	if n.saveDebounceTimer != nil {
		n.saveDebounceTimer.Stop()
	}
	n.saveMutex.Unlock()

	// 6. 退出前强制保存节点列表
	if err := n.SavePeers(); err != nil {
		n.config.Logger.Printf("退出时保存节点失败: %v", err)
	} else {
		n.config.Logger.Println("退出时成功保存节点列表")
	}

	// 7. 关闭 DHT
	if n.dht != nil {
		if err := n.dht.Close(); err != nil {
			n.config.Logger.Printf("关闭 DHT 时出错: %v", err)
		}
	}
	n.config.Logger.Println("成功关闭DHT")

	// 8. 最后关闭 LibP2P 主机（确保底层资源最后释放）
	if err := n.host.Close(); err != nil {
		n.config.Logger.Printf("关闭 LibP2P 主机时出错: %v", err)
		return err
	}

	n.config.Logger.Println("LibP2P 主机已关闭")

	n.config.Logger.Println("网络层已成功关闭")
	return nil
}

// SelfID 返回自身节点ID
func (n *networkLayer) SelfID() string {
	return n.host.ID().String()
}

// SelfAddrs 返回自身节点地址
func (n *networkLayer) SelfAddrs() []multiaddr.Multiaddr {
	return n.host.Addrs()
}

// Connect 连接到指定节点
func (n *networkLayer) Connect(peerInfo PeerInfo) error {
	n.config.Logger.Printf("Connect: %s 开始连接", peerInfo.ID)
	if !n.running {
		return fmt.Errorf("网络层未启动")
	}
	return n.attemptConnect(peerInfo)
}

// 尝试连接到指定节点
func (n *networkLayer) attemptConnect(peerInfo PeerInfo) error {
	n.retryMutex.Lock()
	defer n.retryMutex.Unlock()

	n.config.Logger.Printf("尝试连接")

	if n.host.Network().Connectedness(peer.ID(peerInfo.ID)) == network.Connected {
		return nil
	}

	pid, err := peer.Decode(peerInfo.ID)
	if err != nil {
		return fmt.Errorf("无效节点ID: %w", err)
	}

	addrInfo := peer.AddrInfo{ID: pid, Addrs: peerInfo.Addrs}

	ctx, cancel := context.WithTimeout(n.ctx, 5*time.Second)
	defer cancel()

	// 1. TCP/QUIC 建连
	if err := n.host.Connect(ctx, addrInfo); err != nil {
		return err
	}

	go func() {
		n.config.Logger.Printf("开始握手")
		//TODO 开始握手

	}()
	return nil
}

// Disconnect 断开与指定节点的连接
func (n *networkLayer) Disconnect(peerID string) error {
	if !n.running {
		return fmt.Errorf("网络层未启动")
	}

	pid, err := peer.Decode(peerID)
	if err != nil {
		return fmt.Errorf("无效的节点ID: %w", err)
	}

	n.host.Network().ClosePeer(pid)
	return nil
}

// ConnectedPeers 获取已连接的节点列表
func (n *networkLayer) ConnectedPeers() []PeerInfo {
	peers := make([]PeerInfo, 0)
	for _, pid := range n.host.Network().Peers() {
		peers = append(peers, PeerInfo{
			ID:    pid.String(),
			Addrs: n.host.Peerstore().Addrs(pid),
		})
	}
	return peers
}

// Send 向指定节点发送数据
func (n *networkLayer) SendBack(peerID string, proto protocol.ID, data []byte) ([]byte, error) {
	if !n.running {
		return nil, fmt.Errorf("网络层未启动")
	}

	pid, err := peer.Decode(peerID)
	if err != nil {
		return nil, fmt.Errorf("无效的节点ID: %w", err)
	}

	// 创建流
	stream, err := n.host.NewStream(n.ctx, pid, proto)
	if err != nil {
		return nil, fmt.Errorf("创建流失败: %w", err)
	}
	defer stream.Close()

	// 发送数据
	if _, err := stream.Write(data); err != nil {
		return nil, fmt.Errorf("发送数据失败: %w", err)
	}

	// 读取响应
	buf := make([]byte, 4096)
	readLen, err := stream.Read(buf)
	if err != nil && err != io.EOF {
		return nil, fmt.Errorf("读取响应失败: %w", err)
	}

	return buf[:readLen], nil
}

func (n *networkLayer) Send(peerID string, proto protocol.ID, data []byte) ([]byte, error) {
	if !n.running {
		return nil, fmt.Errorf("网络层未启动")
	}

	pid, err := peer.Decode(peerID)
	if err != nil {
		n.config.Logger.Printf("无效的节点ID: %w", err)
		return nil, err
	}
	stream, err := n.host.NewStream(n.ctx, pid, proto)
	if err != nil {
		return nil, err
	}
	defer stream.Close()

	_ = stream.SetReadDeadline(time.Now().Add(readDeadline))
	_ = stream.SetWriteDeadline(time.Now().Add(writeDeadline))

	if err := safeWriteMsg(stream, pid, data); err != nil {
		return nil, err
	}
	return safeReadMsg(stream, pid)
}

// Broadcast 广播数据到所有已连接节点
func (n *networkLayer) Broadcast(proto protocol.ID, data []byte) map[string]error {
	errors := make(map[string]error)
	peers := n.ConnectedPeers()

	for _, peer := range peers {
		_, err := n.Send(peer.ID, proto, data)
		if err != nil {
			errors[peer.ID] = err
		}
	}
	return errors
}

func (n *networkLayer) BroadcastACK(proto protocol.ID, data []byte, timeout time.Duration, retries int) map[string]error {
	errors := make(map[string]error)
	peers := n.ConnectedPeers()

	// 用于同步等待所有广播操作完成
	var wg sync.WaitGroup

	// 用于控制重传
	retryCh := make(chan string, len(peers))

	// 启动广播操作
	for _, peer := range peers {
		wg.Add(1)
		go func(peer PeerInfo) {
			defer wg.Done()
			// 尝试发送消息
			for attempt := 0; attempt <= retries; attempt++ {
				_, cancel := context.WithTimeout(context.Background(), timeout)
				defer cancel()

				resp, err := n.Send(peer.ID, proto, data)
				if err != nil {
					n.config.Logger.Printf("向 %s 发送广播失败（尝试 %d/%d）: %v", peer.ID, attempt+1, retries+1, err)
					retryCh <- peer.ID
					continue
				}

				// 检查是否收到 ACK
				if string(resp) == "ACK" {
					errors[peer.ID] = nil
					return
				} else {
					n.config.Logger.Printf("从 %s 收到非 ACK 响应: %s", peer.ID, string(resp))
					retryCh <- peer.ID
				}
			}

			// 如果所有尝试都失败
			errors[peer.ID] = fmt.Errorf("所有尝试均失败")
		}(peer)
	}

	// 等待所有广播操作完成
	wg.Wait()

	return errors
}

// RegisterProtocol 注册协议处理器
func (n *networkLayer) RegisterProtocol(proto protocol.ID, handler ProtocolHandler) {
	n.handlerMu.Lock()
	defer n.handlerMu.Unlock()
	n.handlers[proto] = handler

	// 为该协议注册流处理器
	n.host.SetStreamHandler(proto, n.handleStream)
}

// DiscoverPeers 启动节点发现
func (n *networkLayer) DiscoverPeers() (<-chan PeerInfo, error) {
	if !n.running || n.routingDisc == nil {
		return nil, errors.New("网络层未启动或路由发现未初始化")
	}
	peerCh := make(chan PeerInfo, chanBufSize)
	n.wg.Add(1)
	go func() {
		defer n.wg.Done()
		defer close(peerCh)
		ticker := time.NewTicker(15 * time.Second)
		defer ticker.Stop()
		for {
			select {
			case <-n.ctx.Done():
				return
			case <-ticker.C:
				ctx, cancel := context.WithTimeout(n.ctx, discoveryTimeout)
				peerStream, err := n.routingDisc.FindPeers(
					ctx,
					n.config.ProtocolPrefix,
					discovery.Limit(discoveryLimit),
				)
				if err != nil {
					n.config.Logger.Printf("FindPeers 失败: %v", err)
					cancel()
					continue
				}

				// 1. 把 peerStream 转到无缓冲 raw channel，完成后关闭
				raw := make(chan peer.AddrInfo, discoveryLimit)
				go func() {
					defer close(raw)
					for p := range peerStream {
						select {
						case raw <- p:
						case <-ctx.Done():
							return
						}
					}
				}()

				// 2. 启动固定数量 worker
				var wg sync.WaitGroup
				wg.Add(workerNum)
				for i := 0; i < workerNum; i++ {
					go func() {
						defer wg.Done()
						for p := range raw {
							if p.ID.String() == n.SelfID() {
								continue
							}
							select {
							case peerCh <- PeerInfo{
								ID:    p.ID.String(),
								Addrs: p.Addrs,
							}:
							case <-n.ctx.Done():
								return
							}
						}
					}()
				}
				wg.Wait()
				cancel()
			}
		}
	}()
	return peerCh, nil
}

// handleStream 处理流数据 高并发
func (n *networkLayer) handleStream(stream network.Stream) {
	defer stream.Close()
	_ = stream.SetReadDeadline(time.Now().Add(readDeadline))
	_ = stream.SetWriteDeadline(time.Now().Add(writeDeadline))

	peerID := stream.Conn().RemotePeer() // 从流中获取协议ID
	proto := stream.Protocol()
	n.config.Logger.Printf("收到来自 %s 的协议 %s 数据", peerID, proto)

	data, err := safeReadMsg(stream, peerID)
	if err != nil {
		n.config.Logger.Printf("read: %v", err)
		return
	}
	handler, exists := n.handlers[stream.Protocol()]
	var resp []byte
	if !exists {
		n.config.Logger.Printf("未找到协议 %s 的处理器", proto)
		resp = []byte("unsupported wire")
	} else {
		var err error
		resp, err = handler(peerID.String(), data)
		if err != nil {
			n.config.Logger.Printf("处理 %s 协议数据失败: %v", proto, err)
			resp = []byte(err.Error())
		}
	}

	/*	//如果是广播 就回复ACK
		if proto == "/broadcast" {
			resp = []byte("ACK")
		}*/
	// 发送响应

	if resp != nil {
		n.config.Logger.Printf("向 %s 发送回复: %s", peerID, string(resp))
		if err := safeWriteMsg(stream, peerID, resp); err != nil {
			n.config.Logger.Printf("向 %s 发送响应失败: %v", peerID, err)
		}
	}
}

func (n *networkLayer) handleStreamBack(stream network.Stream) {
	defer stream.Close()

	peerID := stream.Conn().RemotePeer().String()
	proto := stream.Protocol() // 从流中获取协议ID
	n.config.Logger.Printf("收到来自 %s 的协议 %s 数据", peerID, proto)

	// 读取数据
	buf := make([]byte, 4096)
	readLen, err := stream.Read(buf)
	if err != nil && err != io.EOF {
		n.config.Logger.Printf("从 %s 读取数据失败: %v", peerID, err)
		return
	}
	data := buf[:readLen]
	handler, exists := n.handlers[proto]
	var response []byte
	if !exists {
		n.config.Logger.Printf("未找到协议 %s 的处理器", proto)
		response = []byte("未支持的协议")
	} else {
		// 调用处理器
		var err error
		response, err = handler(peerID, data)
		if err != nil {
			n.config.Logger.Printf("处理 %s 协议数据失败: %v", proto, err)
			response = []byte("处理数据时出错")
		}
	}

	// 发送响应
	if _, err := stream.Write(response); err != nil {
		n.config.Logger.Printf("向 %s 发送响应失败: %v", peerID, err)
	}
}

// 连接到启动节点
func (n *networkLayer) connectBootstrapPeers() error {
	var lastErr error
	for _, addrStr := range n.config.BootstrapPeers {
		ma, err := multiaddr.NewMultiaddr(addrStr)
		if err != nil {
			n.config.Logger.Printf("解析启动节点地址 %s 失败: %v", addrStr, err)
			lastErr = err
			continue
		}

		info, err := peer.AddrInfoFromP2pAddr(ma)
		if err != nil {
			n.config.Logger.Printf("解析启动节点信息 %s 失败: %v", addrStr, err)
			lastErr = err
			continue
		}

		if err := n.host.Connect(n.ctx, *info); err != nil {
			n.config.Logger.Printf("连接启动节点 %s 失败: %v", info.ID, err)
			lastErr = err
		} else {
			n.config.Logger.Printf("成功连接启动节点: %s", info.ID)
			go func() {
				n.config.Logger.Printf("开始握手")
				//TODO 开始握手
				//获取版本快照
				hash := n.chain.GetGenesisBlockHash()

				handshake := wire.ProtoHandshake{
					GenesisHash: hash[:],
				}
				marshalHandshake, _ := proto.Marshal(&handshake)
				n.Send(info.ID.String(), HandshakeProtocol, marshalHandshake)
			}()
		}
	}
	return lastErr
}

// mdnsNotifee 处理mDNS发现的节点
type mdnsNotifee struct {
	nl *networkLayer
}

func (m *mdnsNotifee) HandlePeerFound(pi peer.AddrInfo) {
	peerID := pi.ID.String()
	if peerID == m.nl.SelfID() {
		return
	}

	// 检查是否已连接
	if m.nl.host.Network().Connectedness(pi.ID) == network.Connected {
		return
	}

	m.nl.config.Logger.Printf("mDNS发现节点: %s", peerID)
	_ = m.nl.Connect(PeerInfo{
		ID:    peerID,
		Addrs: pi.Addrs,
	})
}

// LoadOrGenerateKey 从数据库加载或生成节点密钥
// 使用 PeerKeyBucket 存储，以 PeerPrivateKeyKey 为键
func LoadOrGenerateKey(store db.KeyValueStore) (crypto.PrivKey, error) {
	// 1. 构造完整的数据库键：PeerKeyBucket + PeerPrivateKeyKey
	// 按照db包的设计，使用Bucket的Key方法生成带桶前缀的键
	key := db.MainStatus.Key([]byte(db.PeerPrivateKeyKey))

	var privKey crypto.PrivKey
	// 2. 尝试从数据库读取已存在的密钥
	err := store.Get(key, func(value []byte) error {
		if value == nil {
			return db.ErrKeyNotFound // 密钥不存在，需要生成新的
		}

		// 反序列化私钥
		decodedKey, err := crypto.UnmarshalPrivateKey(value)
		if err != nil {
			return fmt.Errorf("反序列化私钥失败: %w", err)
		}
		privKey = decodedKey
		return nil
	})

	// 处理数据库操作错误（忽略"键不存在"的错误）
	if err != nil && err != db.ErrKeyNotFound {
		return nil, fmt.Errorf("从数据库读取密钥失败: %w", err)
	}

	// 3. 如果密钥不存在，则生成新的Ed25519密钥
	if privKey == nil {
		newPriv, _, err := crypto.GenerateEd25519Key(rand.Reader)
		if err != nil {
			return nil, fmt.Errorf("生成新密钥失败: %w", err)
		}

		// 序列化密钥
		keyBytes, err := crypto.MarshalPrivateKey(newPriv)
		if err != nil {
			return nil, fmt.Errorf("序列化新密钥失败: %w", err)
		}

		// 将新密钥保存到数据库（使用事务确保原子性）
		if err := store.Update(func(batch db.IndexedBatch) error {
			return batch.Put(key, keyBytes)
		}); err != nil {
			return nil, fmt.Errorf("保存新密钥到数据库失败: %w", err)
		}
		privKey = newPriv
	}
	return privKey, nil
}

// 将当前连接的节点转换为PersistentPeer列表
func (n *networkLayer) getPersistentPeers() []PersistentPeer {
	connected := n.ConnectedPeers()
	peers := make([]PersistentPeer, 0, len(connected))

	for _, p := range connected {
		// 转换multiaddr为字符串
		addrStrs := make([]string, 0, len(p.Addrs))
		for _, addr := range p.Addrs {
			addrStrs = append(addrStrs, addr.String())
		}

		peers = append(peers, PersistentPeer{
			ID:       p.ID,
			Addrs:    addrStrs,
			LastSeen: time.Now().Unix(), // 更新最后seen时间为当前时间
		})
	}
	return peers
}

// 保存节点信息到数据库（Protobuf 序列化）
func (n *networkLayer) savePersistentPeers() error {
	// 1. 获取当前连接的节点并转换为 PersistentPeer 列表
	peers := n.getPersistentPeers()
	if len(peers) == 0 {
		n.config.Logger.Println("没有需要保存的节点信息")
		return nil
	}

	// 2. 并发过滤过期/不可达节点
	ctx, cancel := context.WithTimeout(context.Background(), 8*time.Second)
	defer cancel()
	validPeers := n.filterExpiredPeersAsync(ctx, peers, 24*time.Hour)

	if len(validPeers) == 0 {
		n.config.Logger.Println("没有需要保存的有效节点")
		return nil
	}

	// 3. 使用事务批量保存（Protobuf 序列化）
	return n.db.Update(func(batch db.IndexedBatch) error {
		for _, p := range validPeers {
			// 3.1 转换为 Protobuf 消息
			protoPeer := p.ToProto()

			// 3.2 Protobuf 序列化（二进制，比JSON更紧凑）
			data, err := proto.Marshal(protoPeer)
			if err != nil {
				return fmt.Errorf("序列化节点 %s 失败: %w", p.ID, err)
			}

			// 3.3 构造存储键：PersistentPeerBucket + 节点ID（唯一标识）
			key := db.PersistentPeerBucket.Key([]byte(p.ID))

			// 3.4 存入事务（已存在的节点会被覆盖）
			if err := batch.Put(key, data); err != nil {
				return fmt.Errorf("保存节点 %s 失败: %w", p.ID, err)
			}
		}

		n.config.Logger.Printf("成功保存 %d 个节点信息到数据库（Protobuf 格式）", len(validPeers))
		return nil
	})
}

// 从数据库加载节点信息（Protobuf 反序列化）
func (n *networkLayer) loadPersistentPeers() ([]PersistentPeer, error) {
	// 定义结果切片（存储加载的节点）
	var peers []PersistentPeer

	// 1. 构造节点存储桶的前缀（PersistentPeerBucket + 任意键）
	bucketPrefix := db.PersistentPeerBucket.Key()

	// 2. 创建数据库迭代器：仅遍历 PersistentPeerBucket 桶下的所有键值对
	iter, err := n.db.NewIterator(bucketPrefix, true)
	if err != nil {
		return nil, fmt.Errorf("创建节点迭代器失败: %w", err)
	}
	defer iter.Close() // 确保迭代器资源释放

	// 3. 定位到桶的第一个元素（若桶为空，直接返回空列表）
	if !iter.First() {
		n.config.Logger.Println("数据库中无持久化节点数据")
		return peers, nil
	}

	// 4. 遍历桶内所有节点
	for iter.Valid() {
		// 4.1 获取当前节点的 Protobuf 二进制数据
		value, err := iter.Value()
		if err != nil {
			return nil, fmt.Errorf("读取节点数据失败（键: %x）: %w", iter.Key(), err)
		}

		// 4.2 Protobuf 反序列化
		var protoPeer wire.ProtoPersistentPeer
		if err := proto.Unmarshal(value, &protoPeer); err != nil {
			n.config.Logger.Printf("反序列化节点数据失败，跳过该节点（键: %x）: %v", iter.Key(), err)
			iter.Next()
			continue
		}

		// 4.3 转换为 Go 的 PersistentPeer 结构体
		var p PersistentPeer
		p.FromProto(&protoPeer)

		// 4.4 验证节点ID（键与ID需一致，避免脏数据）
		nodeID := string(iter.Key()[len(bucketPrefix):]) // 截取键中的节点ID
		if p.ID != nodeID {
			n.config.Logger.Printf("节点ID与存储键不一致，跳过（键: %s, 节点ID: %s）", nodeID, p.ID)
			iter.Next()
			continue
		}

		// 4.5 添加到结果列表
		peers = append(peers, p)

		// 4.6 移动迭代器到下一个节点
		iter.Next()
	}

	n.config.Logger.Printf("从数据库加载了 %d 个持久化节点信息（Protobuf 格式）", len(peers))
	return peers, nil
}

// ---------- 新增：从 peers.json 中删除指定节点 ----------
// 从数据库中删除指定节点的持久化记录
func (n *networkLayer) removePersistentPeer(targetID string) {
	// 1. 构造目标节点的存储键
	key := db.PersistentPeerBucket.Key([]byte(targetID))

	// 2. 执行删除操作（事务保证原子性）
	err := n.db.Update(func(batch db.IndexedBatch) error {
		return batch.Delete(key)
	})

	// 3. 日志反馈结果
	if err != nil {
		n.config.Logger.Printf("删除节点[%s]失败: %v", targetID, err)
	} else {
		n.config.Logger.Printf("探活失败，已删除节点[%s]的持久化记录", targetID)
	}
}

// 输入：[]PersistentPeer，输出：[]PersistentPeer
func (n *networkLayer) filterExpiredPeersAsync(ctx context.Context, peers []PersistentPeer, maxAge time.Duration) []PersistentPeer {
	now := time.Now().Unix()
	input := make(chan PersistentPeer, len(peers))
	output := make(chan PersistentPeer, len(peers))

	// 1. 先把候选节点塞进 channel
	go func() {
		defer close(input)
		for _, p := range peers {
			if now-p.LastSeen < int64(maxAge.Seconds()) {
				input <- p // 时间过滤
			}
		}
	}()

	// 2. 启动 workerNum 个并发探活协程
	eg, ctx := errgroup.WithContext(ctx)
	for i := 0; i < workerNum; i++ {
		eg.Go(func() error {
			for p := range input {
				valid := n.probePeer(p) // 真正探活
				if valid {
					select {
					case output <- p:
					case <-ctx.Done():
						return ctx.Err()
					}
				}
			}
			return nil
		})
	}

	// 3. 收集结果
	go func() {
		_ = eg.Wait() // 等所有 worker 结束
		close(output)
	}()

	var valid []PersistentPeer
	for p := range output {
		valid = append(valid, p)
	}
	return valid
}

func (n *networkLayer) probePeer(p PersistentPeer) bool {
	// 1. 先看 LRU 缓存
	key := strings.Join(p.Addrs, "|") // 用 | 避免地址里自带逗号冲突

	val, ok := probeCache.Load(key)
	if ok {
		return val.(bool)
	}

	// 2. 快速 TCP/QUIC dial 过滤不可达地址
	var reachable []multiaddr.Multiaddr
	for _, addrStr := range p.Addrs {
		addr, _ := multiaddr.NewMultiaddr(addrStr)
		if n.addrReachable(addr) {
			reachable = append(reachable, addr)
		}
	}
	if len(reachable) == 0 {
		probeCache.Store(key, false) //  失败也缓存
		return false
	}

	// 3. 应用层探活
	pid, _ := peer.Decode(p.ID)
	ctx, cancel := context.WithTimeout(context.Background(), 1*time.Second)
	defer cancel()

	stream, err := n.host.NewStream(ctx, pid, protocol.ID(n.config.ProtocolPrefix+"/ping/1.0.0"))
	if err != nil {
		probeCache.Store(key, false) // 失败缓存
		return false
	}
	defer stream.Close()

	_ = writeMsg(stream, []byte("ping"))
	resp, err := readMsg(stream)
	success := err == nil && string(resp) == "pong"

	// 把结果写进缓存（成功/失败都缓存）
	probeCache.Store(key, success)
	return success
}

// 轻量级探测：TCP/QUIC 都能覆盖
func (n *networkLayer) addrReachable(addr multiaddr.Multiaddr) bool {
	ctx, cancel := context.WithTimeout(context.Background(), 1*time.Second)
	defer cancel()

	// 提取 network+host
	netw, host, err := manet.DialArgs(addr)
	if err != nil {
		return false
	}
	var d net.Dialer
	conn, err := d.DialContext(ctx, netw, host)
	if err != nil {
		return false
	}
	_ = conn.Close()
	return true
}

// 将PersistentPeer转换为PeerInfo（包含有效的multiaddr）
func (n *networkLayer) toPeerInfo(p PersistentPeer) (PeerInfo, error) {
	addrs := make([]multiaddr.Multiaddr, 0, len(p.Addrs))
	for _, addrStr := range p.Addrs {
		addr, err := multiaddr.NewMultiaddr(addrStr)
		if err != nil {
			n.config.Logger.Printf("忽略无效地址 %s（节点 %s）: %v", addrStr, p.ID, err)
			continue // 跳过无效地址
		}
		addrs = append(addrs, addr)
	}

	if len(addrs) == 0 {
		return PeerInfo{}, fmt.Errorf("节点 %s 没有有效地址", p.ID)
	}

	return PeerInfo{
		ID:    p.ID,
		Addrs: addrs,
	}, nil
}

// 在networkLayer结构体中实现
func (n *networkLayer) SavePeers() error {
	return n.savePersistentPeers()
}

// 修改1: 在onPeerConnected的握手goroutine中使用上下文控制
func (n *networkLayer) onPeerConnected(net network.Network, conn network.Conn) {
	peerID := conn.RemotePeer().String()
	dir := conn.Stat().Direction
	n.config.Logger.Printf("节点 %s 已经连接 dir=%v", peerID, dir)
}

// 节点断开连接时触发
func (n *networkLayer) onPeerDisconnected(net network.Network, conn network.Conn) {
	peerID := conn.RemotePeer().String()
	dir := conn.Stat().Direction
	n.config.Logger.Printf("节点 %s 断开连接 dir=%v", peerID, dir)
}

// 防抖保存函数
func (n *networkLayer) debouncedSavePeers() {
	n.saveMutex.Lock()
	defer n.saveMutex.Unlock()

	// 如果已有定时器，停止它
	if n.saveDebounceTimer != nil {
		n.saveDebounceTimer.Stop()
	}

	// 创建新的定时器
	n.saveDebounceTimer = time.AfterFunc(n.saveDebounceDelay, func() {
		// 定时器到期后执行实际保存
		n.saveMutex.Lock()
		n.saveDebounceTimer = nil // 重置定时器
		n.saveMutex.Unlock()
		n.config.Logger.Println("防抖延迟结束，开始保存节点信息")

		if err := n.SavePeers(); err != nil {
			n.config.Logger.Printf("保存节点信息失败: %v", err)
		} else {
			n.config.Logger.Println("节点信息保存成功")
		}

	})
}

func writeMsg(w io.Writer, p []byte) error {
	var header [binary.MaxVarintLen64]byte
	n := binary.PutUvarint(header[:], uint64(len(p)))
	if _, err := w.Write(header[:n]); err != nil {
		return err
	}
	_, err := w.Write(p)
	return err
}

// 读取：先读 varint，再读 body
func readMsg(r io.Reader) ([]byte, error) {
	l, err := binary.ReadUvarint(r.(io.ByteReader))
	if err != nil {
		return nil, err
	}
	if l > 1<<20 {
		return nil, errors.New("message too large")
	}
	buf := make([]byte, l)
	_, err = io.ReadFull(r, buf)
	return buf, err
}

func safeReadMsg(r io.Reader, pid peer.ID) ([]byte, error) {
	// 包装成带缓冲的 ByteReader
	br := bufio.NewReader(r)

	if err := getLimiter(pid).WaitN(context.Background(), 4); err != nil {
		return nil, err
	}
	l, err := binary.ReadUvarint(br) // ← 用 br 而不是 r
	if err != nil {
		return nil, err
	}
	if l > maxMsgSize {
		return nil, errors.New("message too large")
	}
	if err := getLimiter(pid).WaitN(context.Background(), int(l)); err != nil {
		return nil, err
	}
	buf := make([]byte, l)
	if _, err := io.ReadFull(br, buf); err != nil { // ← 继续用 br
		return nil, err
	}
	return buf, nil
}

func safeWriteMsg(w io.Writer, pid peer.ID, p []byte) error {
	if len(p) > maxMsgSize {
		return errors.New("message too large")
	}
	if err := getLimiter(pid).WaitN(context.Background(), 4+len(p)); err != nil {
		return err
	}
	bw := bufio.NewWriter(w)
	var header [binary.MaxVarintLen64]byte
	n := binary.PutUvarint(header[:], uint64(len(p)))
	if _, err := bw.Write(header[:n]); err != nil {
		return err
	}
	if _, err := bw.Write(p); err != nil {
		return err
	}
	return bw.Flush()
}

func (n *networkLayer) BroadcastAsync(ctx context.Context, proto protocol.ID, data []byte) error {
	g, ctx := errgroup.WithContext(ctx)
	sem := make(chan struct{}, 16) // 并发上限
	for _, p := range n.ConnectedPeers() {
		p := p
		g.Go(func() error {
			sem <- struct{}{}
			defer func() { <-sem }()
			_, err := n.Send(p.ID, proto, data)
			return err
		})
	}
	return g.Wait()
}

// ToProto 将PersistentPeer转换为ProtoPersistentPeer
func (p *PersistentPeer) ToProto() *wire.ProtoPersistentPeer {
	// 转换服务能力列表
	protoServices := make([]wire.ServiceFlag, len(p.Services))
	for i, s := range p.Services {
		protoServices[i] = wire.ServiceFlag(s)
	}

	return &wire.ProtoPersistentPeer{
		Id:              p.ID,
		Addrs:           p.Addrs,
		LastSeen:        p.LastSeen,
		Direction:       wire.ConnectionDirection(p.Direction),
		ConnTime:        p.ConnTime,
		DisconnTime:     p.DisconnTime,
		UserAgent:       p.UserAgent,
		ProtocolVersion: p.ProtocolVersion,
		Services:        protoServices,
		SupportedMsgs:   p.SupportedMsgs,
		Rtt:             p.RTT,
		MsgCount:        p.MsgCount,
		BytesSent:       p.BytesSent,
		BytesRecv:       p.BytesRecv,
		UptimeRatio:     p.UptimeRatio,
		BanScore:        p.BanScore,
		BanUntil:        p.BanUntil,
		LastErr:         p.LastErr,
		HandshakeStatus: wire.HandshakeStatus(p.HandshakeStatus),
		RetryCount:      p.RetryCount,
		RetryInterval:   p.RetryInterval,
		IsTrusted:       p.IsTrusted,
	}
}

// FromProto 从ProtoPersistentPeer转换为PersistentPeer
func (p *PersistentPeer) FromProto(protoPeer *wire.ProtoPersistentPeer) {
	// 转换服务能力列表
	services := make([]ServiceFlag, len(protoPeer.Services))
	for i, s := range protoPeer.Services {
		services[i] = ServiceFlag(s)
	}

	p.ID = protoPeer.Id
	p.Addrs = protoPeer.Addrs
	p.LastSeen = protoPeer.LastSeen
	p.Direction = ConnectionDirection(protoPeer.Direction)
	p.ConnTime = protoPeer.ConnTime
	p.DisconnTime = protoPeer.DisconnTime
	p.UserAgent = protoPeer.UserAgent
	p.ProtocolVersion = protoPeer.ProtocolVersion
	p.Services = services
	p.SupportedMsgs = protoPeer.SupportedMsgs
	p.RTT = protoPeer.Rtt
	p.MsgCount = protoPeer.MsgCount
	p.BytesSent = protoPeer.BytesSent
	p.BytesRecv = protoPeer.BytesRecv
	p.UptimeRatio = protoPeer.UptimeRatio
	p.BanScore = protoPeer.BanScore
	p.BanUntil = protoPeer.BanUntil
	p.LastErr = protoPeer.LastErr
	p.HandshakeStatus = HandshakeStatus(protoPeer.HandshakeStatus)
	p.RetryCount = protoPeer.RetryCount
	p.RetryInterval = protoPeer.RetryInterval
	p.IsTrusted = protoPeer.IsTrusted
}
