package cpuminer

import (
	"bitcoin/blockchain"
	"bitcoin/chaincfg/chainhash"
	wire2 "bitcoin/core"
	"bitcoin/mining"
	"bitcoin/utils"
	"bitcoin/wire"
	"fmt"
	"math/big"

	"math/rand"
	"runtime"
	"sync"
	"time"
)

// 共享挖矿结果，所有 worker 只设置一次
type MiningResult struct {
	Found bool
	Nonce uint32
	Hash  chainhash.Hash
	Mu    sync.Mutex
}

type Config struct {
	ChainParams            *wire2.Params
	BlockTemplateGenerator *mining.BlkTmplGenerator
	MiningAddrs            []utils.Address
	ProcessBlock           func(*wire2.Block, blockchain.BehaviorFlags) (bool, error)
	ConnectedCount         func() int32
	IsCurrent              func() bool
}

var (
	defaultNumWorkers = uint32(runtime.NumCPU())
)

type CPUMiner struct {
	sync.Mutex
	g                 *mining.BlkTmplGenerator
	cfg               Config
	numWorkers        uint32
	started           bool
	discreteMining    bool
	submitBlockLock   sync.Mutex
	wg                sync.WaitGroup
	workerWg          sync.WaitGroup
	updateNumWorkers  chan struct{}
	queryHashesPerSec chan float64
	updateHashes      chan uint64
	speedMonitorQuit  chan struct{}
	quit              chan struct{}
}

func New(cfg *Config) *CPUMiner {
	return &CPUMiner{
		g:                 cfg.BlockTemplateGenerator,
		cfg:               *cfg,
		numWorkers:        defaultNumWorkers,
		updateNumWorkers:  make(chan struct{}),
		queryHashesPerSec: make(chan float64),
		updateHashes:      make(chan uint64),
	}
}

func (m *CPUMiner) speedMonitor() {
	log.Tracef("CPU miner speed monitor started")

	var hashesPerSec float64
	var totalHashes uint64
	ticker := time.NewTicker(time.Second * mining.HpsUpdateSecs)
	defer ticker.Stop()

out:
	for {
		select {
		// Periodic updates from the workers with how many hashes they
		// have performed.
		case numHashes := <-m.updateHashes:
			totalHashes += numHashes

		// Time to update the hashes per second.
		case <-ticker.C:
			curHashesPerSec := float64(totalHashes) / mining.HpsUpdateSecs
			if hashesPerSec == 0 {
				hashesPerSec = curHashesPerSec
			}
			hashesPerSec = (hashesPerSec + curHashesPerSec) / 2
			totalHashes = 0
			if hashesPerSec != 0 {
				log.Debugf("Hash speed: %6.0f kilohashes/s",
					hashesPerSec/1000)
			}

		// Request for the number of hashes per second.
		case m.queryHashesPerSec <- hashesPerSec:
			// Nothing to do.

		case <-m.speedMonitorQuit:
			break out
		}
	}

	m.wg.Done()
	log.Tracef("CPU miner speed monitor done")
}

func (m *CPUMiner) Start() {
	m.Lock()
	defer m.Unlock()

	// Nothing to do if the miner is already running or if running in
	// discrete mode (using GenerateNBlocks).
	if m.started || m.discreteMining {
		return
	}

	m.quit = make(chan struct{})
	m.speedMonitorQuit = make(chan struct{})
	m.wg.Add(2)

	go m.speedMonitor()
	go m.miningWorkerController()

	m.started = true
	log.Infof("CPU miner started")
}

func (m *CPUMiner) miningWorkerController() {
	// launchWorkers 改为固定启动1个worker（忽略原numWorkers参数）
	var runningWorkers []chan struct{}

	launchWorkers := func(numWorkers uint32) {
		for i := uint32(0); i < numWorkers; i++ {
			quit := make(chan struct{})
			runningWorkers = append(runningWorkers, quit)
			m.workerWg.Add(1)
			go m.generateBlocks(quit)
		}
	}

	// Launch the current number of workers by default.
	runningWorkers = make([]chan struct{}, 0, m.numWorkers)
	launchWorkers(m.numWorkers)

out:
	for {
		select {
		// Update the number of running workers.
		case <-m.updateNumWorkers:
			// No change.
			numRunning := uint32(len(runningWorkers))
			if m.numWorkers == numRunning {
				continue
			}

			// Add new workers.
			if m.numWorkers > numRunning {
				launchWorkers(m.numWorkers - numRunning)
				continue
			}

			// Signal the most recently created goroutines to exit.
			for i := numRunning - 1; i >= m.numWorkers; i-- {
				close(runningWorkers[i])
				runningWorkers[i] = nil
				runningWorkers = runningWorkers[:i]
			}

		case <-m.quit:
			for _, quit := range runningWorkers {
				close(quit)
			}
			break out
		}
	}

	// Wait until all workers shut down to stop the speed monitor since
	// they rely on being able to send updates to it.
	m.workerWg.Wait()
	close(m.speedMonitorQuit)
	m.wg.Done()
}

func (m *CPUMiner) miningWorkerControllerBack() {
	// launchWorkers 改为固定启动1个worker（忽略原numWorkers参数）
	var runningWorkers []chan struct{}
	launchWorkers := func(_ uint32) { // 参数改为占位符，不实际使用
		quit := make(chan struct{})
		runningWorkers = append(runningWorkers, quit)
		m.workerWg.Add(1)
		go m.generateBlocks(quit) // 仅启动1个generateBlocks协程
	}

	// 初始化：固定启动1个worker（容量设为1优化内存）
	runningWorkers = make([]chan struct{}, 0, 1)
	launchWorkers(1) // 强制传入1，固定启动单个worker

out:
	for {
		select {
		// 移除原"动态调整worker数量"的逻辑（不再响应updateNumWorkers信号）
		// case <-m.updateNumWorkers:
		// 	// 单worker模式下无需调整，直接跳过
		// 	continue

		// 处理停止信号：关闭唯一的worker quit通道
		case <-m.quit:
			for _, quit := range runningWorkers {
				close(quit) // 仅关闭1个worker的通道
			}
			break out
		}
	}

	// 等待唯一的worker退出，再停止速度监控
	m.workerWg.Wait()
	close(m.speedMonitorQuit)
	m.wg.Done()
}

func (m *CPUMiner) generateBlocks(quit chan struct{}) {
	log.Tracef("Starting generate blocks worker")
	// Start a ticker which is used to signal checks for stale work and
	// updates to the speed monitor.
	ticker := time.NewTicker(time.Second * mining.HashUpdateSecs)
	defer ticker.Stop()
out:
	for {
		// Quit when the miner is stopped.
		select {
		case <-quit:
			break out
		default:
			// Non-blocking select to fall through
		}

		m.submitBlockLock.Lock()
		curHeight := m.g.BestSnapshot().Height

		// Choose a payment address at random.
		rand.Seed(time.Now().UnixNano())
		payToAddr := m.cfg.MiningAddrs[rand.Intn(len(m.cfg.MiningAddrs))]

		// Create a new block template using the available transactions
		// in the memory pool as a source of transactions to potentially
		// include in the block.
		template, err := m.g.NewBlockTemplate(payToAddr, curHeight)
		m.submitBlockLock.Unlock()
		if err != nil {
			errStr := fmt.Sprintf("Failed to create new block "+
				"template: %v", err)
			log.Errorf(errStr)
			continue
		}
		if m.solveBlock(template.Block, curHeight+1, ticker, quit) {
			block := wire2.NewBlock(template.Block)
			block.BlockHeight = curHeight + 1
			//工作总量
			bits := block.BlockHeader().Bits
			work := blockchain.CalculateBlockWork(bits)
			chainWork := blockchain.CalculateChainWork(m.g.BestSnapshot().ChainWork, bits)
			sum := new(big.Int)
			sum.Add(work, chainWork)
			err := block.SetChainWork(sum)
			if err != nil {
				return
			}
			log.Infof("当前区块工作总量,%d", sum)
			m.submitBlock(block)
		}
	}

	m.workerWg.Done()
	log.Tracef("Generate blocks worker done")
}

func (m *CPUMiner) Stop() {
	m.Lock()
	defer m.Unlock()

	// Nothing to do if the miner is not currently running or if running in
	// discrete mode (using GenerateNBlocks).
	if !m.started || m.discreteMining {
		return
	}

	close(m.quit)
	m.wg.Wait()
	m.started = false
	log.Infof("CPU miner stopped")
}

func (m *CPUMiner) IsMining() bool {
	m.Lock()
	defer m.Unlock()
	return m.started
}

func (m *CPUMiner) solveBlock(msgBlock *wire2.MsgBlock, blockHeight int32, ticker *time.Ticker, quit chan struct{}) bool {
	enOffset, err := wire.RandomUint64()
	if err != nil {
		log.Errorf("Unexpected error while generating random "+
			"extra nonce offset: %v", err)
		enOffset = 0
	}
	header := &msgBlock.Header
	targetDifficulty := blockchain.CompactToBig(header.Bits)

	//targetDifficulty := blockchain.CompactToBig(blockchain.InitBits)
	/*	log.Infof("当前目标难度 %d", blockchain.InitBits)
		log.Infof("原来难度 %d", header.Bits)*/

	lastGenerated := time.Now()
	lastTxUpdate := m.g.TxSource().LastUpdated()
	hashesCompleted := uint64(0)

	// 外层循环：遍历ExtraNonce（从随机偏移开始）
	for extraNonce := enOffset; extraNonce < mining.MaxExtraNonce; extraNonce++ {
		// 更新当前区块的ExtraNonce
		m.g.UpdateExtraNonce(msgBlock, blockHeight, extraNonce)

		// 初始化worker配置
		numWorkers := m.numWorkers
		if numWorkers == 0 {
			numWorkers = defaultNumWorkers
		}

		// 定义同步通道
		type workerResult struct {
			found bool
			nonce uint32
			hash  chainhash.Hash
		}
		resultChan := make(chan workerResult, numWorkers)
		stopChan := make(chan struct{})
		hashCountChan := make(chan uint64, numWorkers)

		// 拆分Nonce范围
		step := mining.MaxNonce / numWorkers
		if step == 0 {
			step = 1
		}

		// 复制当前区块头，避免并发修改问题
		currentHeader := *header

		// 启动所有worker
		for workerIdx := uint32(0); workerIdx < numWorkers; workerIdx++ {
			startNonce := workerIdx * step
			endNonce := (workerIdx+1)*step - 1
			if workerIdx == numWorkers-1 {
				endNonce = mining.MaxNonce
			}

			// 每个worker使用区块头的副本，避免数据竞争
			workerHeader := currentHeader

			go func(s, e uint32, hdr wire2.BlockHeader) {
				localHashes := uint64(0)
				defer func() {
					hashCountChan <- localHashes
				}()

				for nonce := s; nonce <= e; nonce++ {
					// 检查是否需要停止
					select {
					case <-stopChan:
						return
					case <-quit:
						return
					default:
					}

					// 计算区块哈希
					hdr.Nonce = nonce
					hash := hdr.BlockHash()
					localHashes++ // 修正哈希计数，每次计算计为1
					/*	log.Infof("当前Nonce%d  ExtraNonce %d Hash:%s", nonce, extraNonce, hash)*/
					// 检查是否满足难度要求
					if blockchain.HashToBig(&hash).Cmp(targetDifficulty) <= 0 {
						resultChan <- workerResult{found: true, nonce: nonce, hash: hash}
						return
					}
				}

				// 当前区间无有效解
				resultChan <- workerResult{found: false}
			}(startNonce, endNonce, workerHeader)
		}

		// 主逻辑：监听worker结果、定期检查、退出信号
		workersCompleted := 0
		foundSolution := false
		var solvedNonce uint32
		var solvedHash chainhash.Hash
		exitCurrentEN := false

		for {
			select {
			// 处理worker返回的结果
			case res := <-resultChan:
				workersCompleted++

				if res.found {
					foundSolution = true
					solvedNonce = res.nonce
					solvedHash = res.hash
					close(stopChan)

					// 收集剩余worker的结果和哈希计数
					go func() {
						for ; workersCompleted < int(numWorkers); workersCompleted++ {
							<-resultChan
							<-hashCountChan
						}
					}()
					break
				}

				if workersCompleted == int(numWorkers) {
					// 汇总当前ExtraNonce下的总哈希数
					for i := 0; i < int(numWorkers); i++ {
						hashesCompleted += <-hashCountChan
					}
					log.Debugf("当前ExtraNonce=%d的Nonce范围已耗尽，未找到解，进入下一个ExtraNonce", extraNonce)
					exitCurrentEN = true
					break
				}

			// 定期检查
			case <-ticker.C:
				// 累加已完成worker的哈希计数

				select {
				case hc := <-hashCountChan:
					hashesCompleted += hc
				default:
				}

				// 向速度监控器汇报哈希次数
				m.updateHashes <- hashesCompleted
				hashesCompleted = 0

				// 检查区块是否过期
				bestSnapshot := m.g.BestSnapshot()
				if !header.PrevBlock.IsEqual(&bestSnapshot.Hash) {
					close(stopChan)
					return false // 终止当前求解
				}

				if !header.PrevBlock.IsEqual(&bestSnapshot.Hash) {
					close(stopChan)
					// 清理残留worker资源
					go func() {
						for ; workersCompleted < int(numWorkers); workersCompleted++ {
							<-resultChan
							<-hashCountChan
						}
					}()
					return false
				}

				// 检查内存池交易更新
				if lastTxUpdate != m.g.TxSource().LastUpdated() &&
					time.Now().After(lastGenerated.Add(time.Minute)) {
					close(stopChan)
					go func() {
						for ; workersCompleted < int(numWorkers); workersCompleted++ {
							<-resultChan
							<-hashCountChan
						}
					}()
					return false
				}

				// 更新区块时间
				m.g.UpdateBlockTime(msgBlock, blockHeight)
				currentHeader.Timestamp = header.Timestamp // 更新worker的时间戳

			// 接收外部退出信号
			case <-quit:
				close(stopChan)
				// 清理所有worker资源
				go func() {
					for ; workersCompleted < int(numWorkers); workersCompleted++ {
						<-resultChan
						<-hashCountChan
					}
				}()
				return false
			}

			if foundSolution || exitCurrentEN {
				break
			}
		}

		// 找到有效解
		if foundSolution {
			header.Nonce = solvedNonce
			// 汇总所有worker的哈希计数
			for i := 0; i < int(numWorkers); i++ {
				select {
				case hc := <-hashCountChan:
					hashesCompleted += hc
				default:
				}
			}
			m.updateHashes <- hashesCompleted
			log.Infof("挖矿完成 | 区块高度: %d | ExtraNonce: %d | Nonce: %d | 哈希: %s",
				blockHeight, extraNonce, solvedNonce, solvedHash.String())
			return true
		}
	}

	log.Debugf("已耗尽所有ExtraNonce范围（从%d到%d），未找到有效解", enOffset, mining.MaxExtraNonce)
	return false
}

func (m *CPUMiner) submitBlock(block *wire2.Block) bool {
	log.Info("提交区块")
	m.submitBlockLock.Lock()
	defer m.submitBlockLock.Unlock()

	// Ensure the block is not stale since a new block could have shown up
	// while the solution was being found.  Typically that condition is
	// detected and all work on the stale block is halted to start work on
	// a new block, but the check only happens periodically, so it is
	// possible a block was found and submitted in between.
	msgBlock := block.MsgBlock()
	if !msgBlock.Header.PrevBlock.IsEqual(&m.g.BestSnapshot().Hash) {
		log.Debugf("Block submitted via CPU miner with previous "+
			"block %s is stale", msgBlock.Header.PrevBlock)
		return false
	}

	// Process this block using the same rules as blocks coming from other
	// nodes.  This will in turn relay it to the network like normal.
	isOrphan, err := m.cfg.ProcessBlock(block, blockchain.BFNone)
	if err != nil {
		// Anything other than a rule violation is an unexpected error,
		// so log that error as an internal error.
		if _, ok := err.(blockchain.RuleError); !ok {
			log.Errorf("Unexpected error while processing "+
				"block submitted via CPU miner: %v", err)
			return false
		}

		log.Debugf("Block submitted via CPU miner rejected: %v", err)
		return false
	}
	if isOrphan {
		log.Debugf("Block submitted via CPU miner is an orphan")
		return false
	}

	// The block was accepted.
	coinbaseTx := block.MsgBlock().Transactions[0].TxOut[0]
	log.Infof("Block submitted via CPU miner accepted (hash %s, "+
		"amount %v)", block.Hash(), utils.Amount(coinbaseTx.Value))
	return true
}
