// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.31.1
// source: bitcoin.proto

//import "tx.proto";        // 复用前面定义的 ProtoMsgTx

package wire

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	BitCoinRpc_SendMessage_FullMethodName                = "/wire.BitCoinRpc/SendMessage"
	BitCoinRpc_GetBlock_FullMethodName                   = "/wire.BitCoinRpc/GetBlock"
	BitCoinRpc_GetBlockDTO_FullMethodName                = "/wire.BitCoinRpc/GetBlockDTO"
	BitCoinRpc_SubmitTransaction_FullMethodName          = "/wire.BitCoinRpc/SubmitTransaction"
	BitCoinRpc_StartMining_FullMethodName                = "/wire.BitCoinRpc/StartMining"
	BitCoinRpc_StopMining_FullMethodName                 = "/wire.BitCoinRpc/StopMining"
	BitCoinRpc_JsonSubmitTransaction_FullMethodName      = "/wire.BitCoinRpc/JsonSubmitTransaction"
	BitCoinRpc_GetAllBlock_FullMethodName                = "/wire.BitCoinRpc/GetAllBlock"
	BitCoinRpc_GetAllUTXO_FullMethodName                 = "/wire.BitCoinRpc/GetAllUTXO"
	BitCoinRpc_GetAddressAllUTXO_FullMethodName          = "/wire.BitCoinRpc/GetAddressAllUTXO"
	BitCoinRpc_GetMainBlockByHeight_FullMethodName       = "/wire.BitCoinRpc/GetMainBlockByHeight"
	BitCoinRpc_GetMainStatus_FullMethodName              = "/wire.BitCoinRpc/GetMainStatus"
	BitCoinRpc_GetBlockByHash_FullMethodName             = "/wire.BitCoinRpc/GetBlockByHash"
	BitCoinRpc_GetBlockByHeight_FullMethodName           = "/wire.BitCoinRpc/GetBlockByHeight"
	BitCoinRpc_GetTxByTxId_FullMethodName                = "/wire.BitCoinRpc/GetTxByTxId"
	BitCoinRpc_GetUTXOByTxIdAndOutIndex_FullMethodName   = "/wire.BitCoinRpc/GetUTXOByTxIdAndOutIndex"
	BitCoinRpc_GetAllConnectPeer_FullMethodName          = "/wire.BitCoinRpc/GetAllConnectPeer"
	BitCoinRpc_CreateWallet_FullMethodName               = "/wire.BitCoinRpc/CreateWallet"
	BitCoinRpc_CreateEthAddressByMnemonic_FullMethodName = "/wire.BitCoinRpc/CreateEthAddressByMnemonic"
	BitCoinRpc_CreateBtcAddressByMnemonic_FullMethodName = "/wire.BitCoinRpc/CreateBtcAddressByMnemonic"
	BitCoinRpc_BitCoinTransfer_FullMethodName            = "/wire.BitCoinRpc/BitCoinTransfer"
	BitCoinRpc_GetUnconfirmedTxByAddress_FullMethodName  = "/wire.BitCoinRpc/GetUnconfirmedTxByAddress"
	BitCoinRpc_GetConfirmedTxByAddress_FullMethodName    = "/wire.BitCoinRpc/GetConfirmedTxByAddress"
	BitCoinRpc_GetOnlineAndHandshakePeer_FullMethodName  = "/wire.BitCoinRpc/GetOnlineAndHandshakePeer"
	BitCoinRpc_GetPeerById_FullMethodName                = "/wire.BitCoinRpc/GetPeerById"
	BitCoinRpc_GetPeerByCondition_FullMethodName         = "/wire.BitCoinRpc/GetPeerByCondition"
	BitCoinRpc_GetAllPeer_FullMethodName                 = "/wire.BitCoinRpc/GetAllPeer"
	BitCoinRpc_GetUTXOByAddressAndCache_FullMethodName   = "/wire.BitCoinRpc/GetUTXOByAddressAndCache"
	BitCoinRpc_GetCachaeUTXO_FullMethodName              = "/wire.BitCoinRpc/GetCachaeUTXO"
)

// BitCoinRpcClient is the client API for BitCoinRpc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// 定义服务
type BitCoinRpcClient interface {
	// 支持同时提供原二进制接口和 DTO 接口（按需选择）
	SendMessage(ctx context.Context, in *Message, opts ...grpc.CallOption) (*Message, error)
	GetBlock(ctx context.Context, in *GetBlockRequest, opts ...grpc.CallOption) (*GetBlockReply, error)
	GetBlockDTO(ctx context.Context, in *GetBlockRequestDTO, opts ...grpc.CallOption) (*GetBlockReplyDTO, error)
	SubmitTransaction(ctx context.Context, in *ProtoMsgTx, opts ...grpc.CallOption) (*CommonResp, error)
	// 启动挖矿
	StartMining(ctx context.Context, in *Message, opts ...grpc.CallOption) (*Message, error)
	// 暂停挖矿
	StopMining(ctx context.Context, in *Message, opts ...grpc.CallOption) (*Message, error)
	// 提交一笔交易
	JsonSubmitTransaction(ctx context.Context, in *ProtoMsgTxDTO, opts ...grpc.CallOption) (*CommonResp, error)
	// 查询所有区块 仅测试 后续会删除  返回区块列表
	GetAllBlock(ctx context.Context, in *Message, opts ...grpc.CallOption) (*BlockList, error)
	// 查询所有UTXO 仅测试 后续会删除  返回UTXO列表
	GetAllUTXO(ctx context.Context, in *Message, opts ...grpc.CallOption) (*UtxoList, error)
	// 查询地址下所有的UTXO String类型的地址
	GetAddressAllUTXO(ctx context.Context, in *GetAddressAllUtxoRequest, opts ...grpc.CallOption) (*UtxoList, error)
	GetMainBlockByHeight(ctx context.Context, in *GetMainBlockByHeightReq, opts ...grpc.CallOption) (*GetBlockReplyDTO, error)
	// 查询当前区块链快照
	GetMainStatus(ctx context.Context, in *Message, opts ...grpc.CallOption) (*Message, error)
	// JSON
	GetBlockByHash(ctx context.Context, in *GetBlockByHashReq, opts ...grpc.CallOption) (*JsonBlock, error)
	// 根据
	GetBlockByHeight(ctx context.Context, in *GetBlockByHeightReq, opts ...grpc.CallOption) (*JsonBlock, error)
	// 根据交易ID查询交易
	GetTxByTxId(ctx context.Context, in *GetTxByTxIdReq, opts ...grpc.CallOption) (*JsonTx, error)
	// 根据交易Id和输出索引查询UTXO
	GetUTXOByTxIdAndOutIndex(ctx context.Context, in *GetUTXOByTxIdAndOutIndexReq, opts ...grpc.CallOption) (*JsonUTXO, error)
	// 获取所有的节点
	GetAllConnectPeer(ctx context.Context, in *Message, opts ...grpc.CallOption) (*Message, error)
	// 创建钱包
	CreateWallet(ctx context.Context, in *CreateWalletReq, opts ...grpc.CallOption) (*JsonWallet, error)
	// 根据助记词生成以太坊地址
	CreateEthAddressByMnemonic(ctx context.Context, in *CreateEthAddressByMnemonicReq, opts ...grpc.CallOption) (*EthAddress, error)
	CreateBtcAddressByMnemonic(ctx context.Context, in *CreateBtcAddressByMnemonicReq, opts ...grpc.CallOption) (*BtcAddress, error)
	// 地址到地址的转账  发送方要携带助记词和密码
	BitCoinTransfer(ctx context.Context, in *TransferReq, opts ...grpc.CallOption) (*JsonTx, error)
	// 根据地址获取未确认交易
	GetUnconfirmedTxByAddress(ctx context.Context, in *GetTxByAddressReq, opts ...grpc.CallOption) (*GetTxByAddressRes, error)
	// 查询地址下所有的已经确认的交易
	GetConfirmedTxByAddress(ctx context.Context, in *GetTxByAddressReq, opts ...grpc.CallOption) (*GetTxByAddressRes, error)
	// 获取已经连接且握手的节点
	GetOnlineAndHandshakePeer(ctx context.Context, in *GetPeerReq, opts ...grpc.CallOption) (*GetPeerRes, error)
	// 根据节点ID查询节点信息
	GetPeerById(ctx context.Context, in *GetPeerReq, opts ...grpc.CallOption) (*GetPeerRes, error)
	// 根据服务能力查询已经连接且握手的节点
	GetPeerByCondition(ctx context.Context, in *ProtoPersistentPeer, opts ...grpc.CallOption) (*GetPeerRes, error)
	// 获取所有持久化节点即使未在线
	GetAllPeer(ctx context.Context, in *GetPeerReq, opts ...grpc.CallOption) (*GetPeerRes, error)
	// 查询根据地址查询UTXO 从UTXO缓存中获取
	GetUTXOByAddressAndCache(ctx context.Context, in *GetAddressAllUtxoRequest, opts ...grpc.CallOption) (*UtxoList, error)
	GetCachaeUTXO(ctx context.Context, in *GetAddressAllUtxoRequest, opts ...grpc.CallOption) (*UtxoList, error)
}

type bitCoinRpcClient struct {
	cc grpc.ClientConnInterface
}

func NewBitCoinRpcClient(cc grpc.ClientConnInterface) BitCoinRpcClient {
	return &bitCoinRpcClient{cc}
}

func (c *bitCoinRpcClient) SendMessage(ctx context.Context, in *Message, opts ...grpc.CallOption) (*Message, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Message)
	err := c.cc.Invoke(ctx, BitCoinRpc_SendMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bitCoinRpcClient) GetBlock(ctx context.Context, in *GetBlockRequest, opts ...grpc.CallOption) (*GetBlockReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetBlockReply)
	err := c.cc.Invoke(ctx, BitCoinRpc_GetBlock_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bitCoinRpcClient) GetBlockDTO(ctx context.Context, in *GetBlockRequestDTO, opts ...grpc.CallOption) (*GetBlockReplyDTO, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetBlockReplyDTO)
	err := c.cc.Invoke(ctx, BitCoinRpc_GetBlockDTO_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bitCoinRpcClient) SubmitTransaction(ctx context.Context, in *ProtoMsgTx, opts ...grpc.CallOption) (*CommonResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CommonResp)
	err := c.cc.Invoke(ctx, BitCoinRpc_SubmitTransaction_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bitCoinRpcClient) StartMining(ctx context.Context, in *Message, opts ...grpc.CallOption) (*Message, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Message)
	err := c.cc.Invoke(ctx, BitCoinRpc_StartMining_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bitCoinRpcClient) StopMining(ctx context.Context, in *Message, opts ...grpc.CallOption) (*Message, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Message)
	err := c.cc.Invoke(ctx, BitCoinRpc_StopMining_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bitCoinRpcClient) JsonSubmitTransaction(ctx context.Context, in *ProtoMsgTxDTO, opts ...grpc.CallOption) (*CommonResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CommonResp)
	err := c.cc.Invoke(ctx, BitCoinRpc_JsonSubmitTransaction_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bitCoinRpcClient) GetAllBlock(ctx context.Context, in *Message, opts ...grpc.CallOption) (*BlockList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BlockList)
	err := c.cc.Invoke(ctx, BitCoinRpc_GetAllBlock_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bitCoinRpcClient) GetAllUTXO(ctx context.Context, in *Message, opts ...grpc.CallOption) (*UtxoList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UtxoList)
	err := c.cc.Invoke(ctx, BitCoinRpc_GetAllUTXO_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bitCoinRpcClient) GetAddressAllUTXO(ctx context.Context, in *GetAddressAllUtxoRequest, opts ...grpc.CallOption) (*UtxoList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UtxoList)
	err := c.cc.Invoke(ctx, BitCoinRpc_GetAddressAllUTXO_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bitCoinRpcClient) GetMainBlockByHeight(ctx context.Context, in *GetMainBlockByHeightReq, opts ...grpc.CallOption) (*GetBlockReplyDTO, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetBlockReplyDTO)
	err := c.cc.Invoke(ctx, BitCoinRpc_GetMainBlockByHeight_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bitCoinRpcClient) GetMainStatus(ctx context.Context, in *Message, opts ...grpc.CallOption) (*Message, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Message)
	err := c.cc.Invoke(ctx, BitCoinRpc_GetMainStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bitCoinRpcClient) GetBlockByHash(ctx context.Context, in *GetBlockByHashReq, opts ...grpc.CallOption) (*JsonBlock, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(JsonBlock)
	err := c.cc.Invoke(ctx, BitCoinRpc_GetBlockByHash_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bitCoinRpcClient) GetBlockByHeight(ctx context.Context, in *GetBlockByHeightReq, opts ...grpc.CallOption) (*JsonBlock, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(JsonBlock)
	err := c.cc.Invoke(ctx, BitCoinRpc_GetBlockByHeight_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bitCoinRpcClient) GetTxByTxId(ctx context.Context, in *GetTxByTxIdReq, opts ...grpc.CallOption) (*JsonTx, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(JsonTx)
	err := c.cc.Invoke(ctx, BitCoinRpc_GetTxByTxId_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bitCoinRpcClient) GetUTXOByTxIdAndOutIndex(ctx context.Context, in *GetUTXOByTxIdAndOutIndexReq, opts ...grpc.CallOption) (*JsonUTXO, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(JsonUTXO)
	err := c.cc.Invoke(ctx, BitCoinRpc_GetUTXOByTxIdAndOutIndex_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bitCoinRpcClient) GetAllConnectPeer(ctx context.Context, in *Message, opts ...grpc.CallOption) (*Message, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Message)
	err := c.cc.Invoke(ctx, BitCoinRpc_GetAllConnectPeer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bitCoinRpcClient) CreateWallet(ctx context.Context, in *CreateWalletReq, opts ...grpc.CallOption) (*JsonWallet, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(JsonWallet)
	err := c.cc.Invoke(ctx, BitCoinRpc_CreateWallet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bitCoinRpcClient) CreateEthAddressByMnemonic(ctx context.Context, in *CreateEthAddressByMnemonicReq, opts ...grpc.CallOption) (*EthAddress, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EthAddress)
	err := c.cc.Invoke(ctx, BitCoinRpc_CreateEthAddressByMnemonic_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bitCoinRpcClient) CreateBtcAddressByMnemonic(ctx context.Context, in *CreateBtcAddressByMnemonicReq, opts ...grpc.CallOption) (*BtcAddress, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BtcAddress)
	err := c.cc.Invoke(ctx, BitCoinRpc_CreateBtcAddressByMnemonic_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bitCoinRpcClient) BitCoinTransfer(ctx context.Context, in *TransferReq, opts ...grpc.CallOption) (*JsonTx, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(JsonTx)
	err := c.cc.Invoke(ctx, BitCoinRpc_BitCoinTransfer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bitCoinRpcClient) GetUnconfirmedTxByAddress(ctx context.Context, in *GetTxByAddressReq, opts ...grpc.CallOption) (*GetTxByAddressRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTxByAddressRes)
	err := c.cc.Invoke(ctx, BitCoinRpc_GetUnconfirmedTxByAddress_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bitCoinRpcClient) GetConfirmedTxByAddress(ctx context.Context, in *GetTxByAddressReq, opts ...grpc.CallOption) (*GetTxByAddressRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTxByAddressRes)
	err := c.cc.Invoke(ctx, BitCoinRpc_GetConfirmedTxByAddress_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bitCoinRpcClient) GetOnlineAndHandshakePeer(ctx context.Context, in *GetPeerReq, opts ...grpc.CallOption) (*GetPeerRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetPeerRes)
	err := c.cc.Invoke(ctx, BitCoinRpc_GetOnlineAndHandshakePeer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bitCoinRpcClient) GetPeerById(ctx context.Context, in *GetPeerReq, opts ...grpc.CallOption) (*GetPeerRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetPeerRes)
	err := c.cc.Invoke(ctx, BitCoinRpc_GetPeerById_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bitCoinRpcClient) GetPeerByCondition(ctx context.Context, in *ProtoPersistentPeer, opts ...grpc.CallOption) (*GetPeerRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetPeerRes)
	err := c.cc.Invoke(ctx, BitCoinRpc_GetPeerByCondition_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bitCoinRpcClient) GetAllPeer(ctx context.Context, in *GetPeerReq, opts ...grpc.CallOption) (*GetPeerRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetPeerRes)
	err := c.cc.Invoke(ctx, BitCoinRpc_GetAllPeer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bitCoinRpcClient) GetUTXOByAddressAndCache(ctx context.Context, in *GetAddressAllUtxoRequest, opts ...grpc.CallOption) (*UtxoList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UtxoList)
	err := c.cc.Invoke(ctx, BitCoinRpc_GetUTXOByAddressAndCache_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bitCoinRpcClient) GetCachaeUTXO(ctx context.Context, in *GetAddressAllUtxoRequest, opts ...grpc.CallOption) (*UtxoList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UtxoList)
	err := c.cc.Invoke(ctx, BitCoinRpc_GetCachaeUTXO_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BitCoinRpcServer is the server API for BitCoinRpc service.
// All implementations must embed UnimplementedBitCoinRpcServer
// for forward compatibility.
//
// 定义服务
type BitCoinRpcServer interface {
	// 支持同时提供原二进制接口和 DTO 接口（按需选择）
	SendMessage(context.Context, *Message) (*Message, error)
	GetBlock(context.Context, *GetBlockRequest) (*GetBlockReply, error)
	GetBlockDTO(context.Context, *GetBlockRequestDTO) (*GetBlockReplyDTO, error)
	SubmitTransaction(context.Context, *ProtoMsgTx) (*CommonResp, error)
	// 启动挖矿
	StartMining(context.Context, *Message) (*Message, error)
	// 暂停挖矿
	StopMining(context.Context, *Message) (*Message, error)
	// 提交一笔交易
	JsonSubmitTransaction(context.Context, *ProtoMsgTxDTO) (*CommonResp, error)
	// 查询所有区块 仅测试 后续会删除  返回区块列表
	GetAllBlock(context.Context, *Message) (*BlockList, error)
	// 查询所有UTXO 仅测试 后续会删除  返回UTXO列表
	GetAllUTXO(context.Context, *Message) (*UtxoList, error)
	// 查询地址下所有的UTXO String类型的地址
	GetAddressAllUTXO(context.Context, *GetAddressAllUtxoRequest) (*UtxoList, error)
	GetMainBlockByHeight(context.Context, *GetMainBlockByHeightReq) (*GetBlockReplyDTO, error)
	// 查询当前区块链快照
	GetMainStatus(context.Context, *Message) (*Message, error)
	// JSON
	GetBlockByHash(context.Context, *GetBlockByHashReq) (*JsonBlock, error)
	// 根据
	GetBlockByHeight(context.Context, *GetBlockByHeightReq) (*JsonBlock, error)
	// 根据交易ID查询交易
	GetTxByTxId(context.Context, *GetTxByTxIdReq) (*JsonTx, error)
	// 根据交易Id和输出索引查询UTXO
	GetUTXOByTxIdAndOutIndex(context.Context, *GetUTXOByTxIdAndOutIndexReq) (*JsonUTXO, error)
	// 获取所有的节点
	GetAllConnectPeer(context.Context, *Message) (*Message, error)
	// 创建钱包
	CreateWallet(context.Context, *CreateWalletReq) (*JsonWallet, error)
	// 根据助记词生成以太坊地址
	CreateEthAddressByMnemonic(context.Context, *CreateEthAddressByMnemonicReq) (*EthAddress, error)
	CreateBtcAddressByMnemonic(context.Context, *CreateBtcAddressByMnemonicReq) (*BtcAddress, error)
	// 地址到地址的转账  发送方要携带助记词和密码
	BitCoinTransfer(context.Context, *TransferReq) (*JsonTx, error)
	// 根据地址获取未确认交易
	GetUnconfirmedTxByAddress(context.Context, *GetTxByAddressReq) (*GetTxByAddressRes, error)
	// 查询地址下所有的已经确认的交易
	GetConfirmedTxByAddress(context.Context, *GetTxByAddressReq) (*GetTxByAddressRes, error)
	// 获取已经连接且握手的节点
	GetOnlineAndHandshakePeer(context.Context, *GetPeerReq) (*GetPeerRes, error)
	// 根据节点ID查询节点信息
	GetPeerById(context.Context, *GetPeerReq) (*GetPeerRes, error)
	// 根据服务能力查询已经连接且握手的节点
	GetPeerByCondition(context.Context, *ProtoPersistentPeer) (*GetPeerRes, error)
	// 获取所有持久化节点即使未在线
	GetAllPeer(context.Context, *GetPeerReq) (*GetPeerRes, error)
	// 查询根据地址查询UTXO 从UTXO缓存中获取
	GetUTXOByAddressAndCache(context.Context, *GetAddressAllUtxoRequest) (*UtxoList, error)
	GetCachaeUTXO(context.Context, *GetAddressAllUtxoRequest) (*UtxoList, error)
	mustEmbedUnimplementedBitCoinRpcServer()
}

// UnimplementedBitCoinRpcServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedBitCoinRpcServer struct{}

func (UnimplementedBitCoinRpcServer) SendMessage(context.Context, *Message) (*Message, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendMessage not implemented")
}
func (UnimplementedBitCoinRpcServer) GetBlock(context.Context, *GetBlockRequest) (*GetBlockReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlock not implemented")
}
func (UnimplementedBitCoinRpcServer) GetBlockDTO(context.Context, *GetBlockRequestDTO) (*GetBlockReplyDTO, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlockDTO not implemented")
}
func (UnimplementedBitCoinRpcServer) SubmitTransaction(context.Context, *ProtoMsgTx) (*CommonResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitTransaction not implemented")
}
func (UnimplementedBitCoinRpcServer) StartMining(context.Context, *Message) (*Message, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartMining not implemented")
}
func (UnimplementedBitCoinRpcServer) StopMining(context.Context, *Message) (*Message, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopMining not implemented")
}
func (UnimplementedBitCoinRpcServer) JsonSubmitTransaction(context.Context, *ProtoMsgTxDTO) (*CommonResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method JsonSubmitTransaction not implemented")
}
func (UnimplementedBitCoinRpcServer) GetAllBlock(context.Context, *Message) (*BlockList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllBlock not implemented")
}
func (UnimplementedBitCoinRpcServer) GetAllUTXO(context.Context, *Message) (*UtxoList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllUTXO not implemented")
}
func (UnimplementedBitCoinRpcServer) GetAddressAllUTXO(context.Context, *GetAddressAllUtxoRequest) (*UtxoList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAddressAllUTXO not implemented")
}
func (UnimplementedBitCoinRpcServer) GetMainBlockByHeight(context.Context, *GetMainBlockByHeightReq) (*GetBlockReplyDTO, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMainBlockByHeight not implemented")
}
func (UnimplementedBitCoinRpcServer) GetMainStatus(context.Context, *Message) (*Message, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMainStatus not implemented")
}
func (UnimplementedBitCoinRpcServer) GetBlockByHash(context.Context, *GetBlockByHashReq) (*JsonBlock, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlockByHash not implemented")
}
func (UnimplementedBitCoinRpcServer) GetBlockByHeight(context.Context, *GetBlockByHeightReq) (*JsonBlock, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlockByHeight not implemented")
}
func (UnimplementedBitCoinRpcServer) GetTxByTxId(context.Context, *GetTxByTxIdReq) (*JsonTx, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTxByTxId not implemented")
}
func (UnimplementedBitCoinRpcServer) GetUTXOByTxIdAndOutIndex(context.Context, *GetUTXOByTxIdAndOutIndexReq) (*JsonUTXO, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUTXOByTxIdAndOutIndex not implemented")
}
func (UnimplementedBitCoinRpcServer) GetAllConnectPeer(context.Context, *Message) (*Message, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllConnectPeer not implemented")
}
func (UnimplementedBitCoinRpcServer) CreateWallet(context.Context, *CreateWalletReq) (*JsonWallet, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateWallet not implemented")
}
func (UnimplementedBitCoinRpcServer) CreateEthAddressByMnemonic(context.Context, *CreateEthAddressByMnemonicReq) (*EthAddress, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateEthAddressByMnemonic not implemented")
}
func (UnimplementedBitCoinRpcServer) CreateBtcAddressByMnemonic(context.Context, *CreateBtcAddressByMnemonicReq) (*BtcAddress, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateBtcAddressByMnemonic not implemented")
}
func (UnimplementedBitCoinRpcServer) BitCoinTransfer(context.Context, *TransferReq) (*JsonTx, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BitCoinTransfer not implemented")
}
func (UnimplementedBitCoinRpcServer) GetUnconfirmedTxByAddress(context.Context, *GetTxByAddressReq) (*GetTxByAddressRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUnconfirmedTxByAddress not implemented")
}
func (UnimplementedBitCoinRpcServer) GetConfirmedTxByAddress(context.Context, *GetTxByAddressReq) (*GetTxByAddressRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConfirmedTxByAddress not implemented")
}
func (UnimplementedBitCoinRpcServer) GetOnlineAndHandshakePeer(context.Context, *GetPeerReq) (*GetPeerRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOnlineAndHandshakePeer not implemented")
}
func (UnimplementedBitCoinRpcServer) GetPeerById(context.Context, *GetPeerReq) (*GetPeerRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPeerById not implemented")
}
func (UnimplementedBitCoinRpcServer) GetPeerByCondition(context.Context, *ProtoPersistentPeer) (*GetPeerRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPeerByCondition not implemented")
}
func (UnimplementedBitCoinRpcServer) GetAllPeer(context.Context, *GetPeerReq) (*GetPeerRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllPeer not implemented")
}
func (UnimplementedBitCoinRpcServer) GetUTXOByAddressAndCache(context.Context, *GetAddressAllUtxoRequest) (*UtxoList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUTXOByAddressAndCache not implemented")
}
func (UnimplementedBitCoinRpcServer) GetCachaeUTXO(context.Context, *GetAddressAllUtxoRequest) (*UtxoList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCachaeUTXO not implemented")
}
func (UnimplementedBitCoinRpcServer) mustEmbedUnimplementedBitCoinRpcServer() {}
func (UnimplementedBitCoinRpcServer) testEmbeddedByValue()                    {}

// UnsafeBitCoinRpcServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BitCoinRpcServer will
// result in compilation errors.
type UnsafeBitCoinRpcServer interface {
	mustEmbedUnimplementedBitCoinRpcServer()
}

func RegisterBitCoinRpcServer(s grpc.ServiceRegistrar, srv BitCoinRpcServer) {
	// If the following call pancis, it indicates UnimplementedBitCoinRpcServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&BitCoinRpc_ServiceDesc, srv)
}

func _BitCoinRpc_SendMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Message)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BitCoinRpcServer).SendMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BitCoinRpc_SendMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BitCoinRpcServer).SendMessage(ctx, req.(*Message))
	}
	return interceptor(ctx, in, info, handler)
}

func _BitCoinRpc_GetBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BitCoinRpcServer).GetBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BitCoinRpc_GetBlock_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BitCoinRpcServer).GetBlock(ctx, req.(*GetBlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BitCoinRpc_GetBlockDTO_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBlockRequestDTO)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BitCoinRpcServer).GetBlockDTO(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BitCoinRpc_GetBlockDTO_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BitCoinRpcServer).GetBlockDTO(ctx, req.(*GetBlockRequestDTO))
	}
	return interceptor(ctx, in, info, handler)
}

func _BitCoinRpc_SubmitTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProtoMsgTx)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BitCoinRpcServer).SubmitTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BitCoinRpc_SubmitTransaction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BitCoinRpcServer).SubmitTransaction(ctx, req.(*ProtoMsgTx))
	}
	return interceptor(ctx, in, info, handler)
}

func _BitCoinRpc_StartMining_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Message)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BitCoinRpcServer).StartMining(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BitCoinRpc_StartMining_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BitCoinRpcServer).StartMining(ctx, req.(*Message))
	}
	return interceptor(ctx, in, info, handler)
}

func _BitCoinRpc_StopMining_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Message)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BitCoinRpcServer).StopMining(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BitCoinRpc_StopMining_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BitCoinRpcServer).StopMining(ctx, req.(*Message))
	}
	return interceptor(ctx, in, info, handler)
}

func _BitCoinRpc_JsonSubmitTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProtoMsgTxDTO)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BitCoinRpcServer).JsonSubmitTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BitCoinRpc_JsonSubmitTransaction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BitCoinRpcServer).JsonSubmitTransaction(ctx, req.(*ProtoMsgTxDTO))
	}
	return interceptor(ctx, in, info, handler)
}

func _BitCoinRpc_GetAllBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Message)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BitCoinRpcServer).GetAllBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BitCoinRpc_GetAllBlock_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BitCoinRpcServer).GetAllBlock(ctx, req.(*Message))
	}
	return interceptor(ctx, in, info, handler)
}

func _BitCoinRpc_GetAllUTXO_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Message)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BitCoinRpcServer).GetAllUTXO(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BitCoinRpc_GetAllUTXO_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BitCoinRpcServer).GetAllUTXO(ctx, req.(*Message))
	}
	return interceptor(ctx, in, info, handler)
}

func _BitCoinRpc_GetAddressAllUTXO_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAddressAllUtxoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BitCoinRpcServer).GetAddressAllUTXO(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BitCoinRpc_GetAddressAllUTXO_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BitCoinRpcServer).GetAddressAllUTXO(ctx, req.(*GetAddressAllUtxoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BitCoinRpc_GetMainBlockByHeight_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMainBlockByHeightReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BitCoinRpcServer).GetMainBlockByHeight(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BitCoinRpc_GetMainBlockByHeight_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BitCoinRpcServer).GetMainBlockByHeight(ctx, req.(*GetMainBlockByHeightReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BitCoinRpc_GetMainStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Message)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BitCoinRpcServer).GetMainStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BitCoinRpc_GetMainStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BitCoinRpcServer).GetMainStatus(ctx, req.(*Message))
	}
	return interceptor(ctx, in, info, handler)
}

func _BitCoinRpc_GetBlockByHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBlockByHashReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BitCoinRpcServer).GetBlockByHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BitCoinRpc_GetBlockByHash_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BitCoinRpcServer).GetBlockByHash(ctx, req.(*GetBlockByHashReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BitCoinRpc_GetBlockByHeight_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBlockByHeightReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BitCoinRpcServer).GetBlockByHeight(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BitCoinRpc_GetBlockByHeight_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BitCoinRpcServer).GetBlockByHeight(ctx, req.(*GetBlockByHeightReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BitCoinRpc_GetTxByTxId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTxByTxIdReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BitCoinRpcServer).GetTxByTxId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BitCoinRpc_GetTxByTxId_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BitCoinRpcServer).GetTxByTxId(ctx, req.(*GetTxByTxIdReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BitCoinRpc_GetUTXOByTxIdAndOutIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUTXOByTxIdAndOutIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BitCoinRpcServer).GetUTXOByTxIdAndOutIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BitCoinRpc_GetUTXOByTxIdAndOutIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BitCoinRpcServer).GetUTXOByTxIdAndOutIndex(ctx, req.(*GetUTXOByTxIdAndOutIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BitCoinRpc_GetAllConnectPeer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Message)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BitCoinRpcServer).GetAllConnectPeer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BitCoinRpc_GetAllConnectPeer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BitCoinRpcServer).GetAllConnectPeer(ctx, req.(*Message))
	}
	return interceptor(ctx, in, info, handler)
}

func _BitCoinRpc_CreateWallet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateWalletReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BitCoinRpcServer).CreateWallet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BitCoinRpc_CreateWallet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BitCoinRpcServer).CreateWallet(ctx, req.(*CreateWalletReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BitCoinRpc_CreateEthAddressByMnemonic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateEthAddressByMnemonicReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BitCoinRpcServer).CreateEthAddressByMnemonic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BitCoinRpc_CreateEthAddressByMnemonic_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BitCoinRpcServer).CreateEthAddressByMnemonic(ctx, req.(*CreateEthAddressByMnemonicReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BitCoinRpc_CreateBtcAddressByMnemonic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateBtcAddressByMnemonicReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BitCoinRpcServer).CreateBtcAddressByMnemonic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BitCoinRpc_CreateBtcAddressByMnemonic_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BitCoinRpcServer).CreateBtcAddressByMnemonic(ctx, req.(*CreateBtcAddressByMnemonicReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BitCoinRpc_BitCoinTransfer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransferReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BitCoinRpcServer).BitCoinTransfer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BitCoinRpc_BitCoinTransfer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BitCoinRpcServer).BitCoinTransfer(ctx, req.(*TransferReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BitCoinRpc_GetUnconfirmedTxByAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTxByAddressReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BitCoinRpcServer).GetUnconfirmedTxByAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BitCoinRpc_GetUnconfirmedTxByAddress_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BitCoinRpcServer).GetUnconfirmedTxByAddress(ctx, req.(*GetTxByAddressReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BitCoinRpc_GetConfirmedTxByAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTxByAddressReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BitCoinRpcServer).GetConfirmedTxByAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BitCoinRpc_GetConfirmedTxByAddress_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BitCoinRpcServer).GetConfirmedTxByAddress(ctx, req.(*GetTxByAddressReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BitCoinRpc_GetOnlineAndHandshakePeer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPeerReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BitCoinRpcServer).GetOnlineAndHandshakePeer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BitCoinRpc_GetOnlineAndHandshakePeer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BitCoinRpcServer).GetOnlineAndHandshakePeer(ctx, req.(*GetPeerReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BitCoinRpc_GetPeerById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPeerReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BitCoinRpcServer).GetPeerById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BitCoinRpc_GetPeerById_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BitCoinRpcServer).GetPeerById(ctx, req.(*GetPeerReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BitCoinRpc_GetPeerByCondition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProtoPersistentPeer)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BitCoinRpcServer).GetPeerByCondition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BitCoinRpc_GetPeerByCondition_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BitCoinRpcServer).GetPeerByCondition(ctx, req.(*ProtoPersistentPeer))
	}
	return interceptor(ctx, in, info, handler)
}

func _BitCoinRpc_GetAllPeer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPeerReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BitCoinRpcServer).GetAllPeer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BitCoinRpc_GetAllPeer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BitCoinRpcServer).GetAllPeer(ctx, req.(*GetPeerReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BitCoinRpc_GetUTXOByAddressAndCache_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAddressAllUtxoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BitCoinRpcServer).GetUTXOByAddressAndCache(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BitCoinRpc_GetUTXOByAddressAndCache_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BitCoinRpcServer).GetUTXOByAddressAndCache(ctx, req.(*GetAddressAllUtxoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BitCoinRpc_GetCachaeUTXO_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAddressAllUtxoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BitCoinRpcServer).GetCachaeUTXO(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BitCoinRpc_GetCachaeUTXO_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BitCoinRpcServer).GetCachaeUTXO(ctx, req.(*GetAddressAllUtxoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// BitCoinRpc_ServiceDesc is the grpc.ServiceDesc for BitCoinRpc service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BitCoinRpc_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "wire.BitCoinRpc",
	HandlerType: (*BitCoinRpcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SendMessage",
			Handler:    _BitCoinRpc_SendMessage_Handler,
		},
		{
			MethodName: "GetBlock",
			Handler:    _BitCoinRpc_GetBlock_Handler,
		},
		{
			MethodName: "GetBlockDTO",
			Handler:    _BitCoinRpc_GetBlockDTO_Handler,
		},
		{
			MethodName: "SubmitTransaction",
			Handler:    _BitCoinRpc_SubmitTransaction_Handler,
		},
		{
			MethodName: "StartMining",
			Handler:    _BitCoinRpc_StartMining_Handler,
		},
		{
			MethodName: "StopMining",
			Handler:    _BitCoinRpc_StopMining_Handler,
		},
		{
			MethodName: "JsonSubmitTransaction",
			Handler:    _BitCoinRpc_JsonSubmitTransaction_Handler,
		},
		{
			MethodName: "GetAllBlock",
			Handler:    _BitCoinRpc_GetAllBlock_Handler,
		},
		{
			MethodName: "GetAllUTXO",
			Handler:    _BitCoinRpc_GetAllUTXO_Handler,
		},
		{
			MethodName: "GetAddressAllUTXO",
			Handler:    _BitCoinRpc_GetAddressAllUTXO_Handler,
		},
		{
			MethodName: "GetMainBlockByHeight",
			Handler:    _BitCoinRpc_GetMainBlockByHeight_Handler,
		},
		{
			MethodName: "GetMainStatus",
			Handler:    _BitCoinRpc_GetMainStatus_Handler,
		},
		{
			MethodName: "GetBlockByHash",
			Handler:    _BitCoinRpc_GetBlockByHash_Handler,
		},
		{
			MethodName: "GetBlockByHeight",
			Handler:    _BitCoinRpc_GetBlockByHeight_Handler,
		},
		{
			MethodName: "GetTxByTxId",
			Handler:    _BitCoinRpc_GetTxByTxId_Handler,
		},
		{
			MethodName: "GetUTXOByTxIdAndOutIndex",
			Handler:    _BitCoinRpc_GetUTXOByTxIdAndOutIndex_Handler,
		},
		{
			MethodName: "GetAllConnectPeer",
			Handler:    _BitCoinRpc_GetAllConnectPeer_Handler,
		},
		{
			MethodName: "CreateWallet",
			Handler:    _BitCoinRpc_CreateWallet_Handler,
		},
		{
			MethodName: "CreateEthAddressByMnemonic",
			Handler:    _BitCoinRpc_CreateEthAddressByMnemonic_Handler,
		},
		{
			MethodName: "CreateBtcAddressByMnemonic",
			Handler:    _BitCoinRpc_CreateBtcAddressByMnemonic_Handler,
		},
		{
			MethodName: "BitCoinTransfer",
			Handler:    _BitCoinRpc_BitCoinTransfer_Handler,
		},
		{
			MethodName: "GetUnconfirmedTxByAddress",
			Handler:    _BitCoinRpc_GetUnconfirmedTxByAddress_Handler,
		},
		{
			MethodName: "GetConfirmedTxByAddress",
			Handler:    _BitCoinRpc_GetConfirmedTxByAddress_Handler,
		},
		{
			MethodName: "GetOnlineAndHandshakePeer",
			Handler:    _BitCoinRpc_GetOnlineAndHandshakePeer_Handler,
		},
		{
			MethodName: "GetPeerById",
			Handler:    _BitCoinRpc_GetPeerById_Handler,
		},
		{
			MethodName: "GetPeerByCondition",
			Handler:    _BitCoinRpc_GetPeerByCondition_Handler,
		},
		{
			MethodName: "GetAllPeer",
			Handler:    _BitCoinRpc_GetAllPeer_Handler,
		},
		{
			MethodName: "GetUTXOByAddressAndCache",
			Handler:    _BitCoinRpc_GetUTXOByAddressAndCache_Handler,
		},
		{
			MethodName: "GetCachaeUTXO",
			Handler:    _BitCoinRpc_GetCachaeUTXO_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "bitcoin.proto",
}
